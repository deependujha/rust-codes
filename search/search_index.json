{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Rust codes","text":""},{"location":"01-basics/01-project-setup/01-create-and-run/","title":"Rust Project Setup","text":""},{"location":"01-basics/01-project-setup/01-create-and-run/#install-rust-update","title":"Install rust &amp; update","text":"<pre><code>rustc --version     # Check if Rust is installed &amp; its version\nrustup update       # Update Rust to the latest version\ncargo --version     # Check if Cargo is installed &amp; its version\n</code></pre>"},{"location":"01-basics/01-project-setup/01-create-and-run/#create-a-new-rust-crate","title":"Create a new Rust Crate","text":"<ul> <li>A crate is the smallest compilation unit in Rust.</li> <li>It's either a binary (an executable) or a library (reusable code).</li> <li>When you run cargo new, you create a package, which contains at least one crate.</li> </ul> <pre><code>my_project/\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 main.rs         # Default binary\n\u2502   \u2514\u2500\u2500 lib.rs         # Default library\n\u2514\u2500\u2500 src/bin/\n    \u251c\u2500\u2500 another_bin.rs  # Extra binary crate\n    \u2514\u2500\u2500 tool.rs         # Another binary crate\n</code></pre> <pre><code>cargo new my_project --bin   # Create a new binary crate\n\ncargo new my_library --lib   # Create a new library crate\n\n# -----------------\n\ncargo init my_project --bin  # Initialize in existing directory as binary crate\n\ncargo init my_library --lib  # Initialize in existing directory as library crate\n</code></pre> <p>if you don't specify <code>--bin</code> or <code>--lib</code>, Cargo will create a <code>binary</code> crate by default.</p>"},{"location":"01-basics/01-project-setup/01-create-and-run/#run-the-rust-crate","title":"Run the Rust Crate","text":"<pre><code>cargo run # Run the current crate (main.rs)\n\ncargo run --bin my_project # Run a specific binary crate\n</code></pre>"},{"location":"01-basics/01-project-setup/01-create-and-run/#build-the-rust-crate","title":"Build the Rust Crate","text":"<pre><code>cargo build # Build the current crate (main.rs)\ncargo build --release # Build the current crate in release mode\ncargo build --bin my_project # Build a specific binary crate\ncargo build --bins      # Build all binary crates in the project\n</code></pre>"},{"location":"01-basics/01-project-setup/01-create-and-run/#add-remove-external-crates-to-project","title":"Add &amp; Remove external crates to project","text":"<ul> <li>In existing projects, you can add dependencies by editing the <code>Cargo.toml</code> file.</li> <li>Alternatively, you can use the <code>cargo add</code> command to add crates directly from the command line.</li> </ul> <pre><code>cargo add &lt;crate_name&gt; # Add a crate to your project\n\ncargo remove &lt;crate_name&gt; # Remove a crate from your project\n</code></pre>"},{"location":"01-basics/01-project-setup/01-create-and-run/#install-uninstall-rust-binary-crates","title":"Install &amp; Uninstall rust binary crates","text":"<pre><code>cargo install &lt;crate_name&gt; # Install a binary crate globally\n\ncargo uninstall &lt;crate_name&gt; # Uninstall a binary crate\n</code></pre>"},{"location":"01-basics/01-project-setup/01-create-and-run/#install-local-rust-code-binary-crate","title":"Install local rust code binary crate","text":"<pre><code>cargo install --path . # Install the current crate as a binary\n</code></pre>"},{"location":"01-basics/01-project-setup/01-create-and-run/#cargotoml-vs-cargolock","title":"\ud83d\udce6 Cargo.toml vs Cargo.lock","text":"Feature Cargo.toml Cargo.lock Purpose Declare project &amp; dependency rules Lock exact dependency versions Edited by You (manually) Cargo (automatically) Contains Dependency requirements Exact resolved versions When updated When you change dependencies When dependencies are added/updated Committed to git \u2705 Yes \u2705 Yes (for binaries)\ud83d\udeab No (for libraries) Role Project setup &amp; config Reproducible builds across machines"},{"location":"01-basics/02-concepts/00-input-and-output/","title":"Rust I/O Basics: Output, and Input","text":""},{"location":"01-basics/02-concepts/00-input-and-output/#printing-to-console","title":"Printing to Console","text":"<pre><code>//  `println!` \u2014 Print with newline\n\nprintln!(\"Hello, world!\");\n\n// Print variables with placeholders\nlet name = \"Alice\";\nlet age = 30;\nprintln!(\"{} is {} years old.\", name, age);\n\n// Named placeholders\nprintln!(\"{name} is {age} years old.\", name=name, age=age);\n\n// Debug formatting with `{:?}`\nlet arr = [1, 2, 3];\nprintln!(\"Array: {:?}\", arr);\n\n// ----\n\n// `print!` \u2014 Print without newline\n\nprint!(\"Hello \");\nprint!(\"World!\");\n</code></pre>"},{"location":"01-basics/02-concepts/00-input-and-output/#taking-input-from-user","title":"Taking Input from User","text":"<p>Use the standard library\u2019s <code>std::io</code> module.</p> <p>Info</p> <ul> <li>In Rust, all input from <code>stdin</code> initially comes as a <code>String</code>.</li> <li>You then manually parse that string into the type you want (like <code>i32</code>, <code>f64</code>, <code>bool</code>, etc.) using <code>.parse()</code> with proper error handling.</li> <li>There\u2019s no built-in operator like C++\u2019s <code>cin &gt;&gt; n</code> that automatically reads and converts the input to the variable\u2019s type.</li> </ul> <p>This explicit parsing makes Rust\u2019s input handling a bit more verbose but safer and clearer in intent.</p> <ul> <li>Note: In rust, you always read a whole line as a <code>String</code> and then it's up to you to parse it into the desired type.</li> </ul>"},{"location":"01-basics/02-concepts/00-input-and-output/#read-a-line-from-standard-input","title":"Read a line from standard input","text":"<pre><code>use std::io;\n\nfn main() {\n    let mut input = String::new();\n\n    println!(\"Enter your name:\");\n\n    io::stdin()\n        .read_line(&amp;mut input)\n        .expect(\"Failed to read line\");\n\n    let name = input.trim(); // Remove newline\n    println!(\"Hello, {}!\", name);\n}\n</code></pre>"},{"location":"01-basics/02-concepts/00-input-and-output/#parse-input-into-numbers","title":"Parse input into numbers","text":"<pre><code>use std::io;\n\nfn main() {\n    let mut input = String::new();\n\n    println!(\"Enter a number:\");\n\n    io::stdin()\n        .read_line(&amp;mut input)\n        .expect(\"Failed to read line\");\n\n    let num: i32 = input.trim().parse().expect(\"Please type a number!\");\n    println!(\"You typed: {}\", num);\n}\n</code></pre>"},{"location":"01-basics/02-concepts/00-input-and-output/#read-multiple-words-separately","title":"Read multiple words separately","text":"<pre><code>use std::io;\n\nfn main() {\n    let mut input = String::new();\n    io::stdin().read_line(&amp;mut input).expect(\"Failed to read line\");\n\n    let words: Vec&lt;&amp;str&gt; = input.split_whitespace().collect();\n    println!(\"Words: {:?}\", words);\n}\n</code></pre>"},{"location":"01-basics/02-concepts/00-input-and-output/#read-multiple-integers-in-one-line","title":"Read multiple integers in one line","text":"<pre><code>use std::io;\n\nfn main() {\n    let mut input = String::new();\n\n    println!(\"Enter multiple integers separated by spaces:\");\n\n    io::stdin().read_line(&amp;mut input).expect(\"Failed to read line\");\n\n    let numbers: Vec&lt;i32&gt; = input\n        .split_whitespace()\n        .map(|s| s.parse().expect(\"Please enter valid integers\"))\n        .collect();\n\n    println!(\"You entered: {:?}\", numbers);\n}\n</code></pre>"},{"location":"01-basics/02-concepts/01-conditionals-and-loops/","title":"Conditionals &amp; Loops","text":""},{"location":"01-basics/02-concepts/01-conditionals-and-loops/#conditionals","title":"Conditionals","text":""},{"location":"01-basics/02-concepts/01-conditionals-and-loops/#if-else-if-else","title":"<code>if</code> / <code>else if</code> / <code>else</code>","text":"<pre><code>let num = 7;\n\nif num &lt; 5 {\n    println!(\"Less than 5\");\n} else if num == 5 {\n    println!(\"Equal to 5\");\n} else {\n    println!(\"Greater than 5\");\n}\n</code></pre> <ul> <li> <p>Conditions must be <code>bool</code></p> <p>(doesn't automatically convert types (int, string, etc), like in some languages)</p> </li> <li> <p>No parentheses needed around condition</p> </li> </ul>"},{"location":"01-basics/02-concepts/01-conditionals-and-loops/#match-powerful-pattern-matching","title":"<code>match</code> (Powerful pattern matching)","text":"<pre><code>let num = 3;\n\nmatch num {\n    1 =&gt; println!(\"One\"),\n    2 | 3 =&gt; println!(\"Two or Three\"), // Multiple patterns with `|`\n    4..=6 =&gt; println!(\"Between 4 and 6\"), // Inclusive range\n    _ =&gt; println!(\"Anything else\"),\n}\n</code></pre> <ul> <li>Exhaustive \u2014 all cases must be covered (use <code>_</code> as catch-all)</li> <li>Can match on values, ranges, enums, destructure tuples, structs, etc.</li> </ul> <p>binding default case to some variable in match</p> <ul> <li>If you want to bind the default case to a variable, you can do it like this:</li> </ul> <pre><code>fn main() {\n    let num = 8;\n\n    match num {\n        1 =&gt; println!(\"One\"),\n        2 | 3 =&gt; println!(\"Two or Three\"),\n        4..=6 =&gt; println!(\"Between 4 and 6\"),\n        unmatched =&gt; println!(\"No match found for {}\", unmatched), // bind and print value\n    }\n}\n</code></pre>"},{"location":"01-basics/02-concepts/01-conditionals-and-loops/#loops","title":"Loops","text":""},{"location":"01-basics/02-concepts/01-conditionals-and-loops/#loop-infinite-loop-until-broken","title":"<code>loop</code> (infinite loop until broken)","text":"<pre><code>let mut count = 0;\n\nloop {\n    count += 1;\n    println!(\"count = {}\", count);\n\n    if count == 5 {\n        break; // Exit the loop\n    }\n}\n</code></pre>"},{"location":"01-basics/02-concepts/01-conditionals-and-loops/#while-conditional-loop","title":"<code>while</code> (conditional loop)","text":"<pre><code>let mut num = 3;\n\nwhile num != 0 {\n    println!(\"{}\", num);\n    num -= 1;\n}\nprintln!(\"Liftoff!\");\n</code></pre>"},{"location":"01-basics/02-concepts/01-conditionals-and-loops/#for-iterate-over-a-collection-or-range","title":"<code>for</code> (iterate over a collection or range)","text":"<pre><code>// Over range\nfor i in 1..=5 { // inclusive range 1 to 5\n    println!(\"{}\", i);\n}\n\n// Over array\nlet arr = [10, 20, 30];\nfor val in arr {\n    println!(\"{}\", val);\n}\n</code></pre> <p>ownership in for loops</p> <ul> <li>When iterating over a collection, the ownership of the elements is moved into the loop.</li> <li>If the elements are not <code>Copy</code>, they cannot be used after the loop.</li> </ul> <pre><code>fn main() {\n    let arr = [String::from(\"a\"), String::from(\"b\")];\n\n    for val in arr {\n        println!(\"{}\", val);\n    }\n    // println!(\"{:?}\", arr); // Error! arr has been moved\n}\n</code></pre> <ul> <li>If you want to borrow instead, use <code>iter()</code> or <code>iter_mut()</code>:</li> </ul> <pre><code>let arr = [String::from(\"a\"), String::from(\"b\")];\nfor val in arr.iter() {\n    println!(\"{}\", val); // borrows each element\n}\nprintln!(\"{:?}\", arr);\n</code></pre>"},{"location":"01-basics/02-concepts/01-conditionals-and-loops/#loop-labels-for-nested-loops","title":"Loop labels (for nested loops)","text":"<ul> <li>label is of the form <code>'label_name</code></li> <li>used to break or continue specific loops in nested structures</li> </ul> <pre><code>'outer: for i in 1..=3 {\n    for j in 1..=3 {\n        if i * j == 4 {\n            break 'outer; // breaks the outer loop\n        }\n        println!(\"i = {}, j = {}\", i, j);\n    }\n}\n</code></pre>"},{"location":"01-basics/02-concepts/02-primitive-types/","title":"\ud83e\udde0 Rust Primitive Data Types","text":"<p>Rust has scalar and compound types:</p>"},{"location":"01-basics/02-concepts/02-primitive-types/#scalar-types","title":"\u2705 Scalar Types","text":"Type Description Example Values <code>i8</code>..<code>i128</code> Signed integers (8\u2013128 bits) <code>-42</code>, <code>0</code>, <code>127</code> <code>u8</code>..<code>u128</code> Unsigned integers (8\u2013128 bits) <code>0</code>, <code>255</code>, <code>100</code> <code>isize</code>, <code>usize</code> Pointer-sized int types Architecture dependent <code>f32</code>, <code>f64</code> Floating-point numbers <code>3.14</code>, <code>-2.0</code> <code>bool</code> Boolean <code>true</code>, <code>false</code> <code>char</code> Unicode scalar value (4 bytes) <code>'a'</code>, <code>'\u221e'</code>, <code>'\ud83d\ude80'</code> <p>Default types: <code>i32</code> for integers, <code>f64</code> for floats, <code>char</code> for characters.</p>"},{"location":"01-basics/02-concepts/02-primitive-types/#compound-types","title":"\ud83d\udce6 Compound Types","text":""},{"location":"01-basics/02-concepts/02-primitive-types/#1-tuple","title":"1. Tuple","text":"<p>Fixed-size collection of values (can be of different types).</p> <pre><code>let tup: (i32, f64, char) = (42, 3.14, 'z');\nlet (x, y, z) = tup; // Destructuring\nprintln!(\"{}\", tup.0); // Access with index\n</code></pre>"},{"location":"01-basics/02-concepts/02-primitive-types/#2-array","title":"2. Array","text":"<p>Fixed-size collection of values of the same type.</p> <pre><code>let arr: [i32; 3] = [1, 2, 3];\nprintln!(\"{}\", arr[0]); // Indexing\n</code></pre> <p>Arrays are stack-allocated and have fixed length.</p>"},{"location":"01-basics/02-concepts/02-primitive-types/#type-inference-and-annotation","title":"\ud83d\udd0d Type Inference and Annotation","text":"<p>Rust can infer types, but you can also explicitly specify:</p> <pre><code>let a = 10;           // inferred as i32\nlet b: u64 = 20;      // explicitly u64\nlet pi: f32 = 3.14;\nlet truth: bool = true;\n</code></pre>"},{"location":"01-basics/02-concepts/02-primitive-types/#type-casting-safe-explicit","title":"\ud83e\uddea Type Casting (Safe &amp; Explicit)","text":"<p>Use <code>as</code> for explicit casting:</p> <pre><code>let x: i32 = 42;\nlet y: f64 = x as f64;\n</code></pre> <p>No implicit casting between types (unlike C/C++). Always explicit!</p>"},{"location":"01-basics/02-concepts/02-primitive-types/#common-traits-on-primitives","title":"\ud83d\udee1 Common Traits on Primitives","text":"Trait Use Case <code>Copy</code> Duplicates value (no move) <code>Clone</code> Makes an explicit deep copy <code>Debug</code> Printable with <code>{:?}</code> <code>Default</code> Provides sensible default"},{"location":"01-basics/02-concepts/02-primitive-types/#overflow-special-cases-in-rust-primitives","title":"\u26a0\ufe0f Overflow &amp; Special Cases in Rust Primitives","text":""},{"location":"01-basics/02-concepts/02-primitive-types/#integer-overflow","title":"\ud83d\udd39 Integer Overflow","text":"Mode Behavior Debug \u274c Panic on overflow Release \u2705 Wrap around silently"},{"location":"01-basics/02-concepts/02-primitive-types/#example-debug-mode","title":"Example (Debug mode):","text":"<pre><code>fn main() {\n    let x: u8 = 255;\n    let y = x + 1; // \ud83d\udca5 Panic: attempted to add with overflow\n}\n</code></pre>"},{"location":"01-basics/02-concepts/02-primitive-types/#example-release-mode","title":"Example (Release mode):","text":"<pre><code>fn main() {\n    let x: u8 = 255;\n    let y = x.wrapping_add(1); // \u2705 y = 0 (wraps around)\n}\n</code></pre>"},{"location":"01-basics/02-concepts/02-primitive-types/#safe-integer-operations","title":"\ud83d\udd39 Safe Integer Operations","text":"Method Description <code>wrapping_add(x)</code> Wraps around on overflow <code>checked_add(x)</code> Returns <code>None</code> if overflow occurs <code>saturating_add(x)</code> Clamps to max/min if overflow occurs <code>overflowing_add(x)</code> Returns <code>(value, overflow: bool)</code> <pre><code>let a: u8 = 250;\nprintln!(\"{}\", a.wrapping_add(10));     // \u2192 4\nprintln!(\"{:?}\", a.checked_add(10));    // \u2192 None\nprintln!(\"{}\", a.saturating_add(10));   // \u2192 255\nprintln!(\"{:?}\", a.overflowing_add(10));// \u2192 (4, true)\n</code></pre>"},{"location":"01-basics/02-concepts/02-primitive-types/#signed-integers","title":"\ud83d\udd39 Signed Integers","text":"<p>Signed integers (like <code>i8</code>, <code>i32</code>) overflow just like unsigned ones:</p> <pre><code>let x: i8 = 127;\nlet y = x.wrapping_add(1); // y = -128 (wraps around)\n</code></pre>"},{"location":"01-basics/02-concepts/02-primitive-types/#floating-point-f32-f64","title":"\ud83d\udd39 Floating Point (f32, f64)","text":""},{"location":"01-basics/02-concepts/02-primitive-types/#no-panics-but","title":"No panics, but:","text":"Concept Description Overflow Becomes <code>inf</code> or <code>-inf</code> Underflow Becomes <code>0.0</code> or denormalized subnormal Division by zero Becomes <code>inf</code> or <code>NaN</code> Invalid operations Produce <code>NaN</code> <pre><code>let a = 1e308f64;\nprintln!(\"{}\", a * 10.0); // inf\n\nlet b = 0.0f64;\nprintln!(\"{}\", 1.0 / b);  // inf\n\nlet c: f64 = 0.0 / 0.0;\nprintln!(\"{}\", c.is_nan()); // true\n</code></pre>"},{"location":"01-basics/02-concepts/02-primitive-types/#summary-table","title":"\ud83d\udd39 Summary Table","text":"Type Panics on Overflow Wraps Special Values <code>u8</code>, <code>i32</code> \u2705 Debug mode \u2705 Release - <code>f32</code>, <code>f64</code> \u274c Never panics N/A <code>NaN</code>, <code>inf</code>, <code>-inf</code>"},{"location":"01-basics/02-concepts/03-bytes/","title":"Bytes","text":"<ul> <li><code>Vec&lt;u8&gt;</code> or <code>&amp;[u8]</code> represents raw bytes in Rust</li> <li>Common in file I/O, networking, and binary data handling</li> <li><code>std::io</code> provides traits for reading and writing bytes</li> </ul>"},{"location":"01-basics/02-concepts/03-bytes/#basic-byte-operations","title":"Basic Byte Operations","text":""},{"location":"01-basics/02-concepts/03-bytes/#creating-byte-collections","title":"Creating Byte Collections","text":"<pre><code>// From string\nlet bytes = \"Hello\".as_bytes();\nlet byte_vec = Vec::from(\"Hello\".as_bytes());\n\n// Manual creation\nlet bytes = vec![72, 101, 108, 108, 111];  // \"Hello\"\n\n// From hex\nlet bytes = vec![0xFF, 0x00, 0xAB];\n</code></pre>"},{"location":"01-basics/02-concepts/03-bytes/#converting-bytes","title":"Converting Bytes","text":"<pre><code>fn main() {\n    let bytes = \"Hello\".as_bytes();\n\n    // Bytes to string (safe)\n    let text = String::from_utf8_lossy(bytes);\n\n    // Bytes to string (when sure it's valid UTF-8)\n    if let Ok(text) = String::from_utf8(bytes.to_vec()) {\n        println!(\"{text}\");\n    }\n\n    // Single byte to char (only works for ASCII)\n    let c = bytes[0] as char;\n}\n</code></pre>"},{"location":"01-basics/02-concepts/03-bytes/#file-operations","title":"File Operations","text":""},{"location":"01-basics/02-concepts/03-bytes/#reading-files","title":"Reading Files","text":"<pre><code>use std::fs::File;\nuse std::io::{self, Read, Seek, SeekFrom};\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    // Read entire file into bytes\n    let bytes = std::fs::read(\"file.txt\")?;\n\n    // Read with buffer\n    let mut file = File::open(\"file.txt\")?;\n    let mut buffer = Vec::new();\n    file.read_to_end(&amp;mut buffer)?;\n\n    // Read fixed chunks\n    let mut buffer = [0; 1024];  // 1KB buffer\n    let n = file.read(&amp;mut buffer)?;\n    println!(\"Read {n} bytes\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"01-basics/02-concepts/03-bytes/#writing-files","title":"Writing Files","text":"<pre><code>use std::fs::File;\nuse std::io::Write;\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    // Write bytes to file\n    std::fs::write(\"output.bin\", &amp;[0xFF, 0x00, 0xAB])?;\n\n    // Append to file\n    let mut file = std::fs::OpenOptions::new()\n        .append(true)\n        .open(\"output.bin\")?;\n    file.write_all(&amp;[0xCD, 0xEF])?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"01-basics/02-concepts/03-bytes/#seeking-in-files","title":"Seeking in Files","text":"<pre><code>use std::fs::File;\nuse std::io::{self, Seek, SeekFrom, Read};\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    let mut file = File::open(\"file.bin\")?;\n\n    // Seek from start\n    file.seek(SeekFrom::Start(10))?;\n\n    // Seek from current position\n    file.seek(SeekFrom::Current(5))?;\n\n    // Seek from end\n    file.seek(SeekFrom::End(-5))?;\n\n    // Read after seeking\n    let mut buffer = [0; 10];\n    file.read_exact(&amp;mut buffer)?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"01-basics/02-concepts/03-bytes/#bufreader-and-bufwriter","title":"BufReader and BufWriter","text":"<p><code>BufReader</code> and <code>BufWriter</code> provide buffered I/O operations, which can significantly improve performance when:</p> <ul> <li>Reading/writing small amounts of data frequently</li> <li>Working with large files</li> <li>Dealing with slow devices (like network or disk)</li> </ul>"},{"location":"01-basics/02-concepts/03-bytes/#why-use-them","title":"Why Use Them?","text":"<ul> <li>Reduces system calls by buffering data in memory</li> <li><code>BufReader</code>: Instead of reading one byte at a time, it reads chunks into a buffer</li> <li><code>BufWriter</code>: Collects small writes into larger chunks before writing to disk</li> <li>Can improve performance by 10x or more in some cases</li> </ul> <pre><code>use std::io::{BufReader, BufWriter, Read, Write};\nuse std::fs::File;\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    // Buffered reading\n    let file = File::open(\"large.txt\")?;\n    let mut reader = BufReader::new(file);\n    let mut buffer = String::new();\n    reader.read_to_string(&amp;mut buffer)?;\n\n    // Buffered writing\n    let file = File::create(\"output.txt\")?;\n    let mut writer = BufWriter::new(file);\n    writer.write_all(b\"Hello World\")?;\n    writer.flush()?;  // Don't forget to flush!\n\n    Ok(())\n}\n</code></pre>"},{"location":"01-basics/02-concepts/03-bytes/#reading-a-file-line-by-line","title":"Reading a file <code>line by line</code>","text":"<pre><code>use std::fs::File;\nuse std::io::{self, BufRead};\n\nfn main() -&gt; io::Result&lt;()&gt; {\n    let file = File::open(\"large.txt\")?; // Open the file\n    let reader = io::BufReader::new(file); // Wrap in BufReader\n\n    for line in reader.lines() {\n        let line = line?; // Handle potential errors\n        println!(\"{}\", line);\n    }\n\n    Ok(())\n}\n</code></pre> <p>Remember</p> <ul> <li>Always handle errors with <code>?</code> or <code>unwrap()</code>/<code>expect()</code></li> <li>Use buffered readers/writers for large files</li> <li>Close files implicitly with scope or explicitly with <code>drop()</code></li> <li>Use <code>flush()</code> when writing to ensure all data is written</li> </ul>"},{"location":"01-basics/02-concepts/04-structs/","title":"\ud83c\udfd7\ufe0f Rust Structs &amp; Methods","text":""},{"location":"01-basics/02-concepts/04-structs/#define-a-struct","title":"\ud83d\udce6 Define a Struct","text":"<pre><code>struct Person {\n    name: String,\n    age: u8,\n}\n</code></pre>"},{"location":"01-basics/02-concepts/04-structs/#create-an-instance","title":"\ud83e\uddf1 Create an Instance","text":"<pre><code>let user = Person {\n    name: String::from(\"Alice\"),\n    age: 30,\n};\n</code></pre>"},{"location":"01-basics/02-concepts/04-structs/#access-fields","title":"\ud83e\udde0 Access Fields","text":"<pre><code>println!(\"{} is {} years old\", user.name, user.age);\n</code></pre> <p>You can use dot syntax like <code>user.age</code>.</p>"},{"location":"01-basics/02-concepts/04-structs/#define-methods-with-impl","title":"\ud83d\udee0\ufe0f Define Methods with <code>impl</code>","text":"<pre><code>impl Person {\n    // Method with &amp;self\n    fn greet(&amp;self) {\n        println!(\"Hi, I'm {}!\", self.name);\n    }\n\n    // Method that returns a value\n    fn is_adult(&amp;self) -&gt; bool {\n        self.age &gt;= 18\n    }\n\n    // Associated function (like static)\n    fn new(name: &amp;str, age: u8) -&gt; Self {\n        Person {\n            name: name.to_string(),\n            age,\n        }\n    }\n}\n</code></pre>"},{"location":"01-basics/02-concepts/04-structs/#use-methods","title":"\ud83d\udd28 Use Methods","text":"<pre><code>let alice = Person::new(\"Alice\", 30);\nalice.greet();\nprintln!(\"Is adult? {}\", alice.is_adult());\n</code></pre>"},{"location":"01-basics/02-concepts/04-structs/#mutable-method-with-mut-self","title":"\ud83c\udfaf Mutable Method with <code>&amp;mut self</code>","text":"<pre><code>impl Person {\n    fn have_birthday(&amp;mut self) {\n        self.age += 1;\n    }\n}\n</code></pre> <pre><code>let mut bob = Person::new(\"Bob\", 25);\nbob.have_birthday();\n</code></pre>"},{"location":"01-basics/02-concepts/04-structs/#tuple-structs","title":"\ud83e\uddf1 Tuple Structs","text":"<pre><code>struct Color(u8, u8, u8);\n\nlet red = Color(255, 0, 0);\nprintln!(\"R: {}\", red.0);\n</code></pre>"},{"location":"01-basics/02-concepts/04-structs/#unit-structs","title":"\ud83e\udeb6 Unit Structs","text":"<pre><code>struct Marker;\n\nlet m = Marker;\n</code></pre> <p>Used when you just want a type without data.</p> <p>Example</p> <pre><code>struct JsonSerializer;\n\ntrait Serializer {\n    fn serialize(&amp;self, data: &amp;str) -&gt; String;\n}\n\nimpl Serializer for JsonSerializer {\n    fn serialize(&amp;self, data: &amp;str) -&gt; String {\n        format!(\"{{\\\"data\\\": \\\"{}\\\"}}\", data)\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>let serializer = JsonSerializer;\nprintln!(\"{}\", serializer.serialize(\"hello\"));\n</code></pre>"},{"location":"01-basics/02-concepts/04-structs/#struct-update-syntax","title":"\ud83e\uddec Struct Update Syntax","text":"<pre><code>let person1 = Person {\n    name: String::from(\"Alice\"),\n    age: 25,\n};\n\nlet person2 = Person {\n    name: String::from(\"Bob\"),\n    ..person1\n};\n</code></pre> <p>Moves fields from <code>person1</code>. Only works with non-borrowed types or if fields implement <code>Clone</code>.</p>"},{"location":"01-basics/02-concepts/04-structs/#derive-debug-traits","title":"\ud83d\udccc Derive Debug &amp; Traits","text":"<pre><code>#[derive(Debug, Clone, Copy)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n</code></pre> <pre><code>let p = Point { x: 3, y: 4 };\nprintln!(\"{:?}\", p);\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/","title":"\ud83c\udfad Rust Enums","text":"<p>Enums allow you to define a type by enumerating its possible variants.</p>"},{"location":"01-basics/02-concepts/05-enums/#basic-enum","title":"\ud83d\udce6 Basic Enum","text":"<pre><code>enum Direction {\n    North,\n    South,\n    East,\n    West,\n}\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/#use-it","title":"\u2705 Use It","text":"<pre><code>let dir = Direction::North;\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/#enum-with-data","title":"\ud83d\udcd0 Enum with Data","text":"<pre><code>enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(u8, u8, u8),\n}\n</code></pre> <p>Variants can hold data (like structs or tuples).</p>"},{"location":"01-basics/02-concepts/05-enums/#use-it_1","title":"\u2705 Use It","text":"<pre><code>let msg1 = Message::Write(String::from(\"Hello\"));\nlet msg2 = Message::Move { x: 10, y: 20 };\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/#match-on-enum","title":"\ud83e\udde0 Match on Enum","text":"<pre><code>match msg1 {\n    Message::Write(text) =&gt; println!(\"Message: {}\", text),\n    Message::Move { x, y } =&gt; println!(\"Move to ({}, {})\", x, y),\n    Message::Quit =&gt; println!(\"Quit!\"),\n    Message::ChangeColor(r, g, b) =&gt; println!(\"Color: {}, {}, {}\", r, g, b),\n}\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/#enum-with-methods","title":"\ud83d\udcda Enum with Methods","text":"<pre><code>impl Message {\n    fn call(&amp;self) {\n        match self {\n            Message::Quit =&gt; println!(\"Quit\"),\n            Message::Move { x, y } =&gt; println!(\"Move to ({}, {})\", x, y),\n            Message::Write(text) =&gt; println!(\"Write: {}\", text),\n            Message::ChangeColor(r, g, b) =&gt; println!(\"Color: {}, {}, {}\", r, g, b),\n        }\n    }\n}\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/#enums-with-option-result","title":"\ud83e\ude99 Enums with <code>Option</code> &amp; <code>Result</code>","text":"<p>Rust\u2019s standard library uses enums heavily:</p> <pre><code>let maybe_num: Option&lt;i32&gt; = Some(5);\nlet none_num: Option&lt;i32&gt; = None;\n\nlet result: Result&lt;i32, &amp;str&gt; = Ok(10);\nlet error: Result&lt;i32, &amp;str&gt; = Err(\"Oops\");\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/#matching-on-option","title":"\ud83e\uddea Matching on Option","text":"<pre><code>match maybe_num {\n    Some(n) =&gt; println!(\"Got: {}\", n),\n    None =&gt; println!(\"Nothing here\"),\n}\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/#matching-on-result","title":"\ud83d\udd0d Matching on Result","text":"<pre><code>match result {\n    Ok(v) =&gt; println!(\"Success: {}\", v),\n    Err(e) =&gt; println!(\"Error: {}\", e),\n}\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/#derive-debug","title":"\ud83d\udccc Derive Debug","text":"<pre><code>#[derive(Debug)]\nenum Status {\n    Online,\n    Offline,\n}\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/#if-let-syntax","title":"\ud83d\udd25 <code>if-let</code> Syntax","text":"<pre><code>    let config_max = Some(3u8);\n    match config_max {\n        Some(max) =&gt; println!(\"The maximum is configured to be {max}\"),\n        _ =&gt; (),\n    }\n</code></pre> <p>can be simplified with <code>if let</code>:</p> <pre><code>    let config_max = Some(3u8);\n    if let Some(max) = config_max {\n        println!(\"The maximum is configured to be {max}\");\n    }\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/#let-else-syntax","title":"\ud83d\ude4c\ud83c\udffb <code>let-else</code> Syntax","text":"<ul> <li>original code:</li> </ul> <pre><code>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {\n    let state = if let Coin::Quarter(state) = coin {\n        state\n    } else {\n        return None;\n    };\n\n    if state.existed_in(1900) {\n        Some(format!(\"{state:?} is pretty old, for America!\"))\n    } else {\n        Some(format!(\"{state:?} is relatively new.\"))\n    }\n}\n</code></pre> <ul> <li>can be simplified with <code>let-else</code>:</li> </ul> <pre><code>fn describe_state_quarter(coin: Coin) -&gt; Option&lt;String&gt; {\n    let Coin::Quarter(state) = coin else {\n        return None;\n    };\n\n    if state.existed_in(1900) {\n        Some(format!(\"{state:?} is pretty old, for America!\"))\n    } else {\n        Some(format!(\"{state:?} is relatively new.\"))\n    }\n}\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/#the-operator-in-rust","title":"\u2753 The <code>?</code> Operator in Rust","text":"<p>The <code>?</code> operator is used to propagate errors in functions that return a <code>Result</code> or <code>Option</code>.</p>"},{"location":"01-basics/02-concepts/05-enums/#for-result","title":"\u2705 For <code>Result</code>","text":"<pre><code>fn read_file() -&gt; Result&lt;String, std::io::Error&gt; {\n    let content = std::fs::read_to_string(\"file.txt\")?; // if error, returns it early\n    Ok(content)\n}\n</code></pre> <ul> <li>If <code>read_to_string</code> returns <code>Ok(val)</code>, <code>val</code> is assigned.</li> <li>If it returns <code>Err(e)</code>, the whole function returns <code>Err(e)</code> early.</li> </ul> <p>Equivalent to:</p> <pre><code>let content = match std::fs::read_to_string(\"file.txt\") {\n    Ok(c) =&gt; c,\n    Err(e) =&gt; return Err(e),\n};\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/#for-option","title":"\u2705 For <code>Option</code>","text":"<pre><code>fn get_first_char(s: &amp;str) -&gt; Option&lt;char&gt; {\n    let first = s.chars().next()?; // If None, return None early\n    Some(first)\n}\n</code></pre>"},{"location":"01-basics/02-concepts/05-enums/#requirements","title":"\u2705 Requirements","text":"<ul> <li>The function must return a <code>Result&lt;_, E&gt;</code> or <code>Option&lt;_&gt;</code>.</li> <li>The error type must implement <code>From</code> trait (auto for most common errors).</li> <li>You can only use <code>?</code> inside functions that return compatible types.</li> </ul>"},{"location":"01-basics/02-concepts/05-enums/#good-for","title":"\ud83e\udde0 Good For:","text":"<ul> <li>Cleaner error handling.</li> <li>Early returns on error without boilerplate.</li> </ul>"},{"location":"01-basics/02-concepts/05-enums/#tldr","title":"TL;DR","text":"Use Case Behavior <code>Result</code> Return <code>Err(e)</code> early if error <code>Option</code> Return <code>None</code> early if <code>None</code> <p>Use <code>?</code> to write cleaner, less nested code when dealing with fallible operations.</p>"},{"location":"01-basics/02-concepts/06-traits/","title":"\ud83e\uddec Traits in Rust","text":"<p>Traits are like interfaces in other languages. They define shared behavior that types can implement.</p>"},{"location":"01-basics/02-concepts/06-traits/#define-a-trait","title":"\ud83d\udce6 Define a Trait","text":"<pre><code>trait Speak {\n    fn speak(&amp;self);\n}\n</code></pre>"},{"location":"01-basics/02-concepts/06-traits/#implement-a-trait","title":"\ud83e\uddf1 Implement a Trait","text":"<pre><code>struct Dog;\n\nimpl Speak for Dog {\n    fn speak(&amp;self) {\n        println!(\"Woof!\");\n    }\n}\n</code></pre>"},{"location":"01-basics/02-concepts/06-traits/#use-the-trait","title":"\ud83e\uddea Use the Trait","text":"<pre><code>let d = Dog;\nd.speak(); // Woof!\n</code></pre>"},{"location":"01-basics/02-concepts/06-traits/#trait-for-multiple-types","title":"\ud83e\uddd1\u200d\ud83e\udd1d\u200d\ud83e\uddd1 Trait for Multiple Types","text":"<pre><code>struct Cat;\n\nimpl Speak for Cat {\n    fn speak(&amp;self) {\n        println!(\"Meow!\");\n    }\n}\n</code></pre> <p>Now both <code>Dog</code> and <code>Cat</code> implement <code>Speak</code>.</p>"},{"location":"01-basics/02-concepts/06-traits/#default-methods","title":"\u2728 Default Methods","text":"<p>Traits can have default method implementations:</p> <pre><code>trait Greet {\n    fn greet(&amp;self) {\n        println!(\"Hello!\");\n    }\n}\n\nstruct Person;\n\nimpl Greet for Person {} // uses default\n</code></pre>"},{"location":"01-basics/02-concepts/06-traits/#traits-with-parameters","title":"\ud83d\udce6 Traits with Parameters","text":"<pre><code>trait Addable {\n    fn add(self, other: Self) -&gt; Self;\n}\n\nimpl Addable for i32 {\n    fn add(self, other: Self) -&gt; Self {\n        self + other\n    }\n}\n</code></pre>"},{"location":"01-basics/02-concepts/06-traits/#trait-bounds-generics","title":"\ud83e\uddee Trait Bounds (Generics)","text":"<pre><code>fn print_speak&lt;T: Speak&gt;(item: T) {\n    item.speak();\n}\n</code></pre> <p>Or using shorthand syntax:</p> <pre><code>fn print_speak(item: impl Speak) {\n    item.speak();\n}\n</code></pre>"},{"location":"01-basics/02-concepts/06-traits/#multiple-traits","title":"\ud83e\uddf5 Multiple Traits","text":"<pre><code>fn do_stuff&lt;T: Trait1 + Trait2&gt;(x: T) {\n    // ...\n}\n</code></pre>"},{"location":"01-basics/02-concepts/06-traits/#derive-common-traits","title":"\ud83d\udd0c Derive Common Traits","text":"<p>Rust has built-in traits that you can automatically derive:</p> <pre><code>#[derive(Debug, Clone, Copy, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n</code></pre>"},{"location":"01-basics/02-concepts/06-traits/#common-built-in-traits","title":"\ud83d\udce6 Common Built-in Traits","text":"Trait Purpose <code>Debug</code> <code>{:?}</code> formatting <code>Clone</code> Deep copy <code>Copy</code> Shallow copy (for simple types) <code>PartialEq</code> <code>==</code> and <code>!=</code> <code>Eq</code> Total equality <code>PartialOrd</code> <code>&lt;</code>, <code>&gt;</code>, etc. (partial comparison) <code>Ord</code> Total ordering <code>Default</code> <code>::default()</code> <code>Drop</code> Custom destructor <code>From</code> / <code>Into</code> Type conversions"},{"location":"01-basics/03-data-structures/01-iterators/","title":"\ud83d\udccc Rust Iterators Cheat Sheet","text":""},{"location":"01-basics/03-data-structures/01-iterators/#1-creating-an-iterator","title":"1\ufe0f\u20e3 Creating an Iterator","text":""},{"location":"01-basics/03-data-structures/01-iterators/#basic-iterators","title":"Basic Iterators","text":"<pre><code>let numbers = vec![1, 2, 3, 4, 5];\n\n// `iter()`: Immutable reference to each element\nlet mut iter1 = numbers.iter();\nprintln!(\"{:?}\", iter1.next()); // Some(1)\n\n// `into_iter()`: Takes ownership (moves elements)\nlet mut iter2 = numbers.into_iter();\nprintln!(\"{:?}\", iter2.next()); // Some(1)\n</code></pre> Method Description <code>.iter()</code> Returns an immutable iterator (<code>&amp;T</code>) <code>.iter_mut()</code> Returns a mutable iterator (<code>&amp;mut T</code>) <code>.into_iter()</code> Takes ownership and moves items (<code>T</code>)"},{"location":"01-basics/03-data-structures/01-iterators/#2-consuming-iterators","title":"2\ufe0f\u20e3 Consuming Iterators","text":""},{"location":"01-basics/03-data-structures/01-iterators/#methods-that-iterate-consume","title":"Methods that iterate &amp; consume","text":"<pre><code>let numbers = vec![1, 2, 3, 4, 5];\n\nlet sum: i32 = numbers.iter().sum();\nprintln!(\"Sum: {}\", sum); // 15\n\nlet collected: Vec&lt;_&gt; = numbers.iter().collect();\nprintln!(\"Collected: {:?}\", collected); // [1, 2, 3, 4, 5]\n</code></pre> Method Description <code>.sum()</code> Consumes the iterator and returns the sum <code>.product()</code> Multiplies all elements and returns the result <code>.collect::&lt;Vec&lt;T&gt;&gt;()</code> Collects elements into a vector, set, or hashmap <code>.count()</code> Returns the number of elements"},{"location":"01-basics/03-data-structures/01-iterators/#3-transforming-iterators","title":"3\ufe0f\u20e3 Transforming Iterators","text":""},{"location":"01-basics/03-data-structures/01-iterators/#map-apply-a-function-to-each-item","title":"<code>.map()</code> - Apply a function to each item","text":"<pre><code>let numbers = vec![1, 2, 3];\nlet doubled: Vec&lt;_&gt; = numbers.iter().map(|x| x * 2).collect();\nprintln!(\"{:?}\", doubled); // [2, 4, 6]\n</code></pre>"},{"location":"01-basics/03-data-structures/01-iterators/#4-filtering-iterators","title":"4\ufe0f\u20e3 Filtering Iterators","text":""},{"location":"01-basics/03-data-structures/01-iterators/#filter-keep-items-that-satisfy-a-condition","title":"<code>.filter()</code> - Keep items that satisfy a condition","text":"<pre><code>let numbers = vec![1, 2, 3, 4, 5];\nlet even_numbers: Vec&lt;_&gt; = numbers.iter().filter(|&amp;&amp;x| x % 2 == 0).collect();\nprintln!(\"{:?}\", even_numbers); // [2, 4]\n</code></pre> Method Description <code>.filter(|x| condition)</code> Keeps elements that return <code>true</code> <code>.filter_map(|x| Some(y))</code> Like <code>map()</code>, but skips <code>None</code> values"},{"location":"01-basics/03-data-structures/01-iterators/#5-combining-iterators","title":"5\ufe0f\u20e3 Combining Iterators","text":""},{"location":"01-basics/03-data-structures/01-iterators/#chain-concatenate-two-iterators","title":"<code>.chain()</code> - Concatenate two iterators","text":"<pre><code>let a = vec![1, 2, 3];\nlet b = vec![4, 5, 6];\nlet combined: Vec&lt;_&gt; = a.iter().chain(b.iter()).collect();\nprintln!(\"{:?}\", combined); // [1, 2, 3, 4, 5, 6]\n</code></pre>"},{"location":"01-basics/03-data-structures/01-iterators/#6-finding-checking-elements","title":"6\ufe0f\u20e3 Finding &amp; Checking Elements","text":"<pre><code>let numbers = vec![1, 2, 3, 4, 5];\n\nlet any_even = numbers.iter().any(|&amp;x| x % 2 == 0);\nprintln!(\"Any even? {}\", any_even); // true\n\nlet all_even = numbers.iter().all(|&amp;x| x % 2 == 0);\nprintln!(\"All even? {}\", all_even); // false\n\nlet first_even = numbers.iter().find(|&amp;&amp;x| x % 2 == 0);\nprintln!(\"First even: {:?}\", first_even); // Some(2)\n</code></pre> Method Description <code>.any(|x| condition)</code> Returns <code>true</code> if any element matches <code>.all(|x| condition)</code> Returns <code>true</code> if all elements match <code>.find(|x| condition)</code> Returns the first element that matches"},{"location":"01-basics/03-data-structures/01-iterators/#7-taking-skipping-elements","title":"7\ufe0f\u20e3 Taking &amp; Skipping Elements","text":"<pre><code>let numbers = vec![1, 2, 3, 4, 5];\n\nlet first_two: Vec&lt;_&gt; = numbers.iter().take(2).collect();\nprintln!(\"{:?}\", first_two); // [1, 2]\n\nlet skip_two: Vec&lt;_&gt; = numbers.iter().skip(2).collect();\nprintln!(\"{:?}\", skip_two); // [3, 4, 5]\n</code></pre> Method Description <code>.take(n)</code> Takes first <code>n</code> elements <code>.skip(n)</code> Skips first <code>n</code> elements"},{"location":"01-basics/03-data-structures/01-iterators/#8-zipping-iterators","title":"8\ufe0f\u20e3 Zipping Iterators","text":""},{"location":"01-basics/03-data-structures/01-iterators/#zip-pair-two-iterators-together","title":"<code>.zip()</code> - Pair two iterators together","text":"<pre><code>let a = vec![1, 2, 3];\nlet b = vec!['a', 'b', 'c'];\nlet zipped: Vec&lt;_&gt; = a.iter().zip(b.iter()).collect();\nprintln!(\"{:?}\", zipped); // [(1, 'a'), (2, 'b'), (3, 'c')]\n</code></pre>"},{"location":"01-basics/03-data-structures/01-iterators/#9-enumerating-items","title":"9\ufe0f\u20e3 Enumerating Items","text":""},{"location":"01-basics/03-data-structures/01-iterators/#enumerate-attach-an-index","title":"<code>.enumerate()</code> - Attach an index","text":"<pre><code>let letters = vec!['a', 'b', 'c'];\nfor (index, letter) in letters.iter().enumerate() {\n    println!(\"{}: {}\", index, letter);\n}\n// 0: a\n// 1: b\n// 2: c\n</code></pre>"},{"location":"01-basics/03-data-structures/01-iterators/#lazy-vs-consuming-iterators","title":"\ud83d\udd1f Lazy vs. Consuming Iterators","text":"<p>Rust iterators are lazy, meaning they only compute when needed.</p>"},{"location":"01-basics/03-data-structures/01-iterators/#lazy-example-does-nothing","title":"Lazy Example (Does Nothing)","text":"<pre><code>let _lazy = (1..5).map(|x| x * 2);  // Does nothing\n</code></pre>"},{"location":"01-basics/03-data-structures/01-iterators/#forcing-computation-uses-collect","title":"Forcing Computation (Uses <code>collect()</code>)","text":"<pre><code>let result: Vec&lt;_&gt; = (1..5).map(|x| x * 2).collect();\nprintln!(\"{:?}\", result); // [2, 4, 6, 8]\n</code></pre>"},{"location":"01-basics/03-data-structures/01-iterators/#summary","title":"\ud83d\udccc Summary","text":"Category Methods Creating Iterators <code>.iter()</code>, <code>.iter_mut()</code>, <code>.into_iter()</code> Consuming Iterators <code>.sum()</code>, <code>.product()</code>, <code>.collect()</code>, <code>.count()</code> Transforming <code>.map(|x| ...)</code> Filtering <code>.filter(|x| ...)</code>, <code>.filter_map(|x| Some(y))</code> Combining <code>.chain()</code> Finding <code>.any()</code>, <code>.all()</code>, <code>.find()</code> Taking/Skipping <code>.take(n)</code>, <code>.skip(n)</code> Zipping <code>.zip()</code> Enumerating <code>.enumerate()</code>"},{"location":"01-basics/03-data-structures/02-strings/","title":"Rust String Methods","text":"<p>Rust's <code>String</code> and <code>&amp;str</code> types provide many useful methods similar to Python's string methods. Below is a list of common operations and their equivalents in Rust.</p>"},{"location":"01-basics/03-data-structures/02-strings/#checking-prefix-suffix","title":"Checking Prefix &amp; Suffix","text":"<pre><code>let s = \"hello world\";\nassert!(s.starts_with(\"hello\"));\nassert!(s.ends_with(\"world\"));\nassert!(s.contains(\"lo\"));\n</code></pre>"},{"location":"01-basics/03-data-structures/02-strings/#trimming-whitespace","title":"Trimming Whitespace","text":"<pre><code>let s = \"  hello  \";\nassert_eq!(s.trim(), \"hello\");\nassert_eq!(s.trim_start(), \"hello  \");\nassert_eq!(s.trim_end(), \"  hello\");\n</code></pre>"},{"location":"01-basics/03-data-structures/02-strings/#modifying-case","title":"Modifying Case","text":"<pre><code>let s = \"Hello\";\nassert_eq!(s.to_lowercase(), \"hello\");\nassert_eq!(s.to_uppercase(), \"HELLO\");\n</code></pre>"},{"location":"01-basics/03-data-structures/02-strings/#splitting-joining","title":"Splitting &amp; Joining","text":"<ul> <li><code>split</code>: Splits a string on a delimiter.</li> </ul> <pre><code>let s = \"a,b,c\";\nlet parts: Vec&lt;&amp;str&gt; = s.split(',').collect();\nassert_eq!(parts, vec![\"a\", \"b\", \"c\"]);\n</code></pre> <ul> <li><code>split_whitespace</code>: Splits by whitespace.</li> </ul> <pre><code>let s = \"hello   world\";\nlet parts: Vec&lt;&amp;str&gt; = s.split_whitespace().collect();\nassert_eq!(parts, vec![\"hello\", \"world\"]);\n</code></pre> <p><code>splitn</code>: Splits a string into a maximum of N substrings.</p> <pre><code>let s = \"a,b,c,d\";\nlet parts: Vec&lt;&amp;str&gt; = s.splitn(2, ',').collect();\nassert_eq!(parts, vec![\"a\", \"b,c,d\"]);\n</code></pre> <ul> <li><code>join</code>: Joins an iterator of strings with a separator.</li> </ul> <pre><code>let words = vec![\"hello\", \"world\"];\nlet s = words.join(\" \");\nassert_eq!(s, \"hello world\");\n</code></pre>"},{"location":"01-basics/03-data-structures/02-strings/#replacing-removing-characters","title":"Replacing &amp; Removing Characters","text":"<ul> <li><code>replace</code>: Replaces all occurrences of a substring.</li> </ul> <pre><code>let s = \"hello world\";\nassert_eq!(s.replace(\"world\", \"Rust\"), \"hello Rust\");\n</code></pre> <ul> <li><code>replacen</code>: Replaces the first N occurrences.</li> </ul> <pre><code>let s = \"hello world world\";\nassert_eq!(s.replacen(\"world\", \"Rust\", 1), \"hello Rust world\");\n</code></pre> <ul> <li><code>trim_matches</code>: Trims specific characters from start and end.</li> </ul> <pre><code>let s = \"---hello---\";\nassert_eq!(s.trim_matches('-'), \"hello\");\n</code></pre> <ul> <li><code>trim_start_matches</code>: Trims specific characters from start.</li> </ul> <pre><code>let s = \"s3://hello\";\nassert_eq!(s.trim_start_matches(\"s3://\"), \"hello\");\n</code></pre>"},{"location":"01-basics/03-data-structures/02-strings/#indexing-slicing","title":"Indexing &amp; Slicing","text":"<ul> <li><code>chars</code>: Iterates over characters.</li> </ul> <pre><code>let s = \"hello\";\nfor c in s.chars() {\n    println!(\"{}\", c);\n}\n</code></pre> <ul> <li><code>bytes</code>: Iterates over bytes.</li> </ul> <pre><code>let s = \"hello\";\nfor b in s.bytes() {\n    println!(\"{}\", b);\n}\n</code></pre> <ul> <li>Slicing: Getting a substring using byte indices.</li> </ul> <pre><code>let s = \"hello world\";\nlet sub = &amp;s[0..5];\nassert_eq!(sub, \"hello\");\n</code></pre> <p>\u26a0 Note: Rust strings are UTF-8 encoded, so slicing must align with character boundaries.</p>"},{"location":"01-basics/03-data-structures/02-strings/#checking-empty-or-length","title":"Checking Empty or Length","text":"<ul> <li><code>is_empty</code>: Checks if a string is empty.</li> </ul> <pre><code>let s = \"\";\nassert!(s.is_empty());\n</code></pre> <ul> <li><code>len</code>: Gets the length (in bytes, not characters!).</li> </ul> <pre><code>let s = \"hello\";\nassert_eq!(s.len(), 5);\n</code></pre>"},{"location":"01-basics/03-data-structures/02-strings/#converting-between-strings","title":"Converting Between Strings","text":"<ul> <li><code>to_string</code>: Converts into a <code>String</code>.</li> </ul> <pre><code>let s = \"hello\".to_string();\n</code></pre> <ul> <li><code>String::from</code>: Creates a <code>String</code> from a <code>&amp;str</code>.</li> </ul> <pre><code>let s = String::from(\"hello\");\n</code></pre>"},{"location":"01-basics/03-data-structures/03-hashmap/","title":"Hashmap","text":"<ul> <li><code>HashMap</code> is a collection of key-value pairs.</li> <li>Used to store data in a way that allows for fast retrieval of values by their keys.</li> <li>The keys must be <code>Hash</code> and <code>Eq</code> traits.</li> <li>The values must be <code>Copy</code> trait.</li> </ul>"},{"location":"01-basics/03-data-structures/03-hashmap/#creating-a-hashmap","title":"Creating a HashMap","text":""},{"location":"01-basics/03-data-structures/03-hashmap/#hashmapnew","title":"<code>HashMap::new()</code>","text":"<pre><code>use std::collections::HashMap;\n\n// Type inference lets us omit an explicit type signature (which\n// would be `HashMap&lt;String, String&gt;` in this example).\nlet mut book_reviews = HashMap::new();\n\n// Review some books.\nbook_reviews.insert(\n    \"Adventures of Huckleberry Finn\".to_string(),\n    \"My favorite book.\".to_string(),\n);\n</code></pre>"},{"location":"01-basics/03-data-structures/03-hashmap/#hashmapfrom","title":"<code>HashMap::from</code>","text":"<ul> <li>A HashMap with a known list of items can be initialized from an array:</li> </ul> <pre><code>use std::collections::HashMap;\n\nlet solar_distance = HashMap::from([\n    (\"Mercury\", 0.4),\n    (\"Venus\", 0.7),\n    (\"Earth\", 1.0),\n    (\"Mars\", 1.5),\n]);\n</code></pre>"},{"location":"01-basics/03-data-structures/03-hashmap/#hashmap-methods","title":"HashMap methods","text":"<p>Methods</p> <ul> <li><code>insert</code>: Insert a key-value pair into the HashMap.</li> <li><code>get</code>: Get a value by key.</li> <li><code>remove</code>: Remove a key-value pair from the HashMap.</li> <li><code>contains_key</code>: Check if a key exists in the HashMap.</li> <li><code>clear</code>: Remove all key-value pairs from the HashMap.</li> <li><code>is_empty</code>: Check if the HashMap is empty.</li> <li><code>len</code>: Get the number of key-value pairs in the HashMap.</li> <li><code>capacity</code>: Get the capacity of the HashMap.</li> </ul> <pre><code>use std::collections::HashMap;\n\nfn main() {\n    let mut map: HashMap&lt;u8, &amp;str&gt; = HashMap::new();\n\n    let names = vec![\"Deependu\", \"Nitesh\", \"Akash\", \"Bhim\"];\n\n    let mut roll = 1;\n    for name in names {\n        map.insert(roll, name);\n        roll += 1;\n    }\n\n    // print hashmap\n    println!(\"{map:?}\");\n\n    // get all the students\n    while roll &gt; 1 {\n        roll -= 1;\n        let student = map.get(&amp;roll);\n        if let Some(s) = student {\n            println!(\"Roll: {roll} =&gt; {s}\");\n        }\n    }\n\n    let cap = map.capacity();\n    let mut is_eppy = map.is_empty();\n    let mut len = map.len();\n\n    println!(\"{is_eppy}; {map:?}; {len}; {cap}\");\n    map.clear();\n    is_eppy = map.is_empty();\n    len = map.len();\n    println!(\"{is_eppy}; {map:?}; {len}; {cap}\");\n\n    // map.entry(key). -- inplace modification of key corresponding entries\n    let is_2_present = map.contains_key(&amp;(2 as u8));\n    let is_22_present = map.contains_key(&amp;(22 as u8));\n    println!(\"{is_2_present}; {is_22_present}\");\n\n    // -------- remove --------\n    map.remove(&amp;2);\n\n    let is_2_present = map.contains_key(&amp;(2 as u8));\n    let is_22_present = map.contains_key(&amp;(22 as u8));\n    println!(\"{is_2_present}; {is_22_present}\");\n}\n</code></pre>"},{"location":"01-basics/03-data-structures/03-hashmap/#in-place-modification-of-key-entries","title":"In-Place modification of key entries","text":"<ul> <li><code>entry(key)</code>: Gets the given key's corresponding entry in the map for in-place manipulation.</li> </ul> <p>useful methods</p> <ul> <li><code>or_insert(value)</code>: Inserts the given value if the key is not present in the map.</li> <li><code>or_insert_with(generator)</code>: Inserts the given value if the key is not present in the map.</li> <li><code>or_default()</code>: Inserts the default value if the key is not present in the map.</li> <li><code>and_modify(f)</code>: Inserts the given value if the key is not present in the map.</li> </ul> <pre><code>use std::collections::HashMap;\n\nfn main() {\n    let mut map: HashMap&lt;i32, u32&gt; = HashMap::new();\n\n    // Ensures a value is in the entry by inserting the default value if empty\n    map.entry(1).or_default();\n    assert!(map.get(&amp;1) == Some(&amp;0));\n\n    // Ensures a value is in the entry by inserting the default if empty\n    map.entry(2).or_insert(1);\n    assert!(map.get(&amp;2) == Some(&amp;1));\n\n    // Provides in-place mutable access to an occupied entry before any potential inserts into the map.\n    map.entry(3).and_modify(|e| *e += 1);\n    assert!(map.get(&amp;3) == None); // since `3` doesn't already exist in the map\n\n    // if not already present, insert a value, else update the value.\n    map.entry(3).and_modify(|e| *e += 1).or_insert(0);\n    assert!(map.get(&amp;3) == Some(&amp;0)); // since `3` doesn't already exist in the map\n\n    for _ in 0..3 {\n        map.entry(3).and_modify(|e| *e += 1).or_insert(0);\n    }\n    assert!(map.get(&amp;3) == Some(&amp;3)); // since `3` doesn't already exist in the map\n\n    // Ensures a value is in the entry by inserting the result of the default function if empty\n    map.entry(4).or_insert_with(|| 3 * 2 + 5);\n    assert!(map.get(&amp;4) == Some(&amp;11)); // since `3` doesn't already exist in the map\n\n    // Ensures a value is in the entry by inserting,\n    // This method allows for generating key-derived values for insertion by providing\n    // the default function a reference to the key that was moved during the .entry(key) method call.\n    map.entry(5).or_insert_with_key(|k| ((*k) * 2 + 7) as u32);\n    assert!(map.get(&amp;5) == Some(&amp;17)); // since `3` doesn't already exist in the map\n}\n</code></pre>"},{"location":"01-basics/03-data-structures/03-hashmap/#iterating-over-a-hashmap","title":"Iterating over a HashMap","text":"<p>Methods</p> <ul> <li><code>iter</code>: Iterate over the key-value pairs in the map.</li> <li><code>iter_mut</code>: Iterate over the key-value pairs in the map, yielding mutable references.</li> <li><code>into_iter</code>: Iterate over the key-value pairs in the map, yielding owned values.</li> <li><code>iter().map()</code>: Apply a function to each key-value pair in the map.</li> <li><code>iter().filter()</code>: Filter the key-value pairs in the map.</li> <li><code>iter().for_each()</code>: Apply a function to each key-value pair in the map.</li> <li><code>iter().all()</code>: Check if all key-value pairs in the map satisfy a condition.</li> <li><code>iter().any()</code>: Check if any key-value pair in the map satisfies a condition.</li> <li><code>iter().collect()</code>: Collect the key-value pairs in the map into a vector.</li> <li><code>iter().enumerate()</code>: Iterate over the key-value pairs in the map, yielding the index and the key-value pair.</li> </ul> <pre><code>use std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n\n    for i in 1..11 {\n        map.insert(i, i * 2);\n    }\n\n    // iterate\n    for (k, v) in map.iter().enumerate() {\n        println!(\"{k} =&gt; {v:?}\")\n    }\n\n    // iter_mut\n    for (_, v) in map.iter_mut() {\n        *v *= 2;\n    }\n\n    let y = map.iter().all(|k_v| ((*(k_v.1)) % 2) == 0);\n    map.iter().for_each(|zz| {\n        let (_k, _v) = zz;\n        // return (*_k) + (*_v);\n        println!(\"{_k}; {_v}\");\n    });\n    println!(\"{y}\")\n}\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/","title":"Vectors","text":"<ul> <li><code>Vec&lt;T&gt;</code> is a resizable array type in Rust</li> <li>Elements are stored in contiguous memory</li> <li>Can only store elements of the same type</li> <li>Zero-cost abstraction over arrays</li> </ul>"},{"location":"01-basics/03-data-structures/04-vectors/#rust-range-iterator","title":"Rust <code>Range Iterator</code>","text":"<pre><code>for i in 0..5 {\n    println!(\"{}\", i);\n}\n// Output: 0 1 2 3 4\n\nfor i in 0..=5 {\n    println!(\"{}\", i);\n}\n// Output: 0 1 2 3 4 5\n\nlet numbers: Vec&lt;i32&gt; = (0..5).collect();\nprintln!(\"{:?}\", numbers);\n// Output: [0, 1, 2, 3, 4]\n\n// ------- reverse -------\n\nlet numbers: Vec&lt;i32&gt; = (0..5).rev().collect();\nprintln!(\"{:?}\", numbers);\n// Output: [4, 3, 2, 1, 0]\n\nfor i in (0..5).rev() {\n    println!(\"{}\", i);\n}\n\n// ------- step by -------\n\nlet numbers: Vec&lt;i32&gt; = (0..10).step_by(2).collect();\nprintln!(\"{:?}\", numbers);\n// Output: [0, 2, 4, 6, 8]\n\n// ------- take -------\n\nfor i in (0..).take(5) {  // Infinite range, but taking first 5 elements\n    println!(\"{}\", i);\n}\n// Output: 0 1 2 3 4\n\n// ------- filter -------\n\nlet odd_numbers: Vec&lt;i32&gt; = (0..10).filter(|x| x % 2 == 1).collect();\nprintln!(\"{:?}\", odd_numbers);\n// Output: [1, 3, 5, 7, 9]\n\n// ------- chain -------\n\nlet numbers: Vec&lt;i32&gt; = (0..3).chain(7..10).collect();\nprintln!(\"{:?}\", numbers);\n// Output: [0, 1, 2, 7, 8, 9]\n\n// ------- array slicing -------\n\nlet arr = [10, 20, 30, 40, 50];\nlet slice = &amp;arr[1..4]; // Indexing works with ranges\n\nprintln!(\"{:?}\", slice);\n// Output: [20, 30, 40]\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#summary-of-range-features","title":"Summary of Range Features","text":"Rust Range Equivalent Python Explanation <code>0..5</code> <code>range(5)</code> From <code>0</code> to <code>4</code> (exclusive) <code>0..=5</code> <code>range(6)</code> From <code>0</code> to <code>5</code> (inclusive) <code>(0..5).collect()</code> <code>list(range(5))</code> Converts to <code>Vec&lt;i32&gt;</code> <code>(0..5).rev()</code> <code>reversed(range(5))</code> Reverse order <code>(0..10).step_by(2)</code> <code>range(0, 10, 2)</code> Steps of <code>2</code> <code>(0..).take(5)</code> <code>itertools.islice(itertools.count(0), 5)</code> Infinite iterator, taking first 5 values <code>(0..10).filter(|x| x % 2 == 1)</code> <code>[x for x in range(10) if x % 2 == 1]</code> Filtering elements <code>(0..3).chain(7..10)</code> <code>list(range(3)) + list(range(7,10))</code> Chaining ranges"},{"location":"01-basics/03-data-structures/04-vectors/#creating-vectors","title":"Creating Vectors","text":""},{"location":"01-basics/03-data-structures/04-vectors/#empty-vector","title":"Empty Vector","text":"<pre><code>let mut nums: Vec&lt;i32&gt; = Vec::new();\n// or with type inference\nlet mut nums = vec![];\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#with-initial-values","title":"With Initial Values","text":"<pre><code>// Using vec! macro\nlet nums = vec![1, 2, 3, 4, 5];\n\n// From array\nlet nums = Vec::from([1, 2, 3, 4, 5]);\n\n// converting array to vector\nlet arr = [1, 2, 3, 4, 5];\nlet nums = arr.to_vec();\n\n// With repeated values\nlet zeros = vec![0; 5]; // Creates [0, 0, 0, 0, 0]\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#common-methods","title":"Common Methods","text":"<p>Methods</p> <ul> <li><code>push</code>: Add element to end</li> <li><code>pop</code>: Remove and return last element</li> <li><code>insert</code>: Insert element at index</li> <li><code>remove</code>: Remove element at index</li> <li><code>clear</code>: Remove all elements</li> <li><code>len</code>: Get length</li> <li><code>capacity</code>: Get current capacity</li> <li><code>is_empty</code>: Check if empty</li> <li><code>get</code>: Get reference to element</li> <li><code>first</code>/<code>last</code>: Get first/last element</li> </ul> <pre><code>fn main() {\n    let mut nums = Vec::new();\n\n    // Adding elements\n    nums.push(1);\n    nums.push(2);\n    nums.push(3);\n\n    // Accessing elements\n    let second = nums[1]; // Direct access\n    let second = nums.get(1); // Safe access (returns Option)\n\n    // Removing elements\n    let last = nums.pop(); // removes and returns 3\n    nums.remove(0); // removes 1\n\n    // Info\n    let length = nums.len();\n    let is_empty = nums.is_empty();\n\n    // Clear\n    nums.clear();\n}\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#2d-vectors","title":"2D Vectors","text":""},{"location":"01-basics/03-data-structures/04-vectors/#creating-2d-vectors","title":"Creating 2D Vectors","text":"<pre><code>// Empty 2D vector\nlet mut grid: Vec&lt;Vec&lt;i32&gt;&gt; = Vec::new();\n\n// Initialize with size\nlet rows = 3;\nlet cols = 4;\nlet grid = vec![vec![0; cols]; rows];\n\n// With values\nlet matrix = vec![\n    vec![1, 2, 3],\n    vec![4, 5, 6],\n    vec![7, 8, 9]\n];\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#working-with-2d-vectors","title":"Working with 2D Vectors","text":"<pre><code>fn main() {\n    let mut grid = vec![vec![0; 3]; 3];\n\n    // Modify element\n    grid[0][1] = 5;\n\n    // Access element\n    let val = grid[1][2];\n\n    // Iterate over 2D vector\n    for row in &amp;grid {\n        for &amp;cell in row {\n            print!(\"{} \", cell);\n        }\n        println!();\n    }\n\n    // Add new row\n    grid.push(vec![1, 1, 1]);\n\n    // Get dimensions\n    let rows = grid.len();\n    let cols = grid[0].len();\n}\n</code></pre> <p>Remember</p> <ul> <li>Each row can have different lengths (jagged array)</li> <li>Use <code>grid[row][col]</code> for access</li> <li>Be careful with bounds when accessing elements</li> </ul>"},{"location":"01-basics/03-data-structures/04-vectors/#safe-way-to-set-a-value-at-some-index","title":"Safe way to set a value at some index","text":"<pre><code>let mut numbers = vec![1, 2, 3, 4, 5];\nif let Some(value) = numbers.get_mut(2) {  // Safe: Check if index exists\n    *value = 99;  // Modify safely\n}\nprintln!(\"{:?}\", numbers); // Output: [1, 2, 99, 4, 5]\n\n// ----- another way -----\nlet mut numbers = vec![1, 2, 3, 4, 5];\n*numbers.get_mut(2).expect(\"Index out of bounds\") = 99;\nprintln!(\"{:?}\", numbers); // Output: [1, 2, 99, 4, 5]\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#iterating-over-a-vector","title":"Iterating over a vector","text":"<p>Methods</p> <ul> <li><code>iter</code>: Get immutable iterator</li> <li><code>iter_mut</code>: Get mutable iterator</li> <li><code>enumerate</code>: Get index and value</li> <li><code>all</code>: Check if all elements satisfy a condition</li> <li><code>any</code>: Check if any element satisfies a condition</li> <li><code>find</code>: Find first element satisfying a condition</li> <li><code>fold</code>: Aggregate elements</li> <li><code>map</code>: Apply a function to each element</li> <li><code>filter</code>: Filter elements</li> <li><code>collect</code>: Collect elements into a new collection</li> </ul> <pre><code>let nums = vec![1, 2, 3, 4, 5];\n\nfor num in nums {\n    println!(\"{num}\");\n}\n\n// ----- another way -----\nfor i in 0..nums.len() {\n    println!(\"{}\", nums[i]);\n}\n\n// ----- another way -----\nfor num in nums.iter() {\n    println!(\"{num}\");\n}\n\n// ----- another way -----\nfor (i, num) in nums.iter().enumerate() {\n    println!(\"{}: {}\", i, num);\n}\n\n// ----- another way -----\nfor num in nums.iter_mut() {\n    *num *= 2;\n}\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#filtering-elements","title":"Filtering elements","text":"<pre><code>let nums = vec![1, 2, 3, 4, 5];\n\nlet even_nums = nums.iter().filter(|&amp;num| num % 2 == 0).collect::&lt;Vec&lt;_&gt;&gt;();\n\nprintln!(\"{:?}\", even_nums); // Output: [2, 4]\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#mapping-elements","title":"Mapping elements","text":"<pre><code>let nums = vec![1, 2, 3, 4, 5];\n\nlet squares = nums.iter().map(|num| num * num).collect::&lt;Vec&lt;_&gt;&gt;();\n\nprintln!(\"{:?}\", squares); // Output: [1, 4, 9, 16, 25]\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#aggregating-elements","title":"Aggregating elements","text":"<pre><code>let nums = vec![1, 2, 3, 4, 5];\n\nlet sum = nums.iter().sum::&lt;i32&gt;();\n\nprintln!(\"{}\", sum); // Output: 15\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#finding-elements","title":"Finding elements","text":"<pre><code>let nums = vec![1, 2, 3, 4, 5];\n\nlet first_even = nums.iter().find(|&amp;num| num % 2 == 0);\n\nprintln!(\"{:?}\", first_even); // Output: Some(2)\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#sorting-elements","title":"Sorting elements","text":"<pre><code>let mut nums = vec![3, 1, 2, 4, 5];\n\nnums.sort();\n\nprintln!(\"{:?}\", nums); // Output: [1, 2, 3, 4, 5]\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#removing-elements","title":"Removing elements","text":"<pre><code>let mut nums = vec![1, 2, 3, 4, 5];\n\nnums.remove(0); // removes 1\n\nprintln!(\"{:?}\", nums); // Output: [2, 3, 4, 5]\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#removing-duplicates","title":"Removing duplicates","text":"<pre><code>let mut nums = vec![1, 2, 2, 3, 4, 4, 5];\n\nnums.dedup();\nprintln!(\"{:?}\", nums); // Output: [1, 2, 3, 4, 5]\n</code></pre>"},{"location":"01-basics/03-data-structures/04-vectors/#all-any","title":"<code>All</code> &amp; <code>Any</code>","text":"<pre><code>let nums = vec![1, 2, 3, 4, 5];\n\nlet all_even = nums.iter().all(|&amp;num| num % 2 == 0);\nlet any_even = nums.iter().any(|&amp;num| num % 2 == 0);\n\nprintln!(\"{}\", all_even); // Output: false\nprintln!(\"{}\", any_even); // Output: true\n</code></pre>"},{"location":"01-basics/04-macros/01-declarative-macro/","title":"Declarative Macros","text":"<pre><code>macro_rules! fibonacci {\n    ($x: expr) =&gt; {\n        if($x&lt;2){\n            $x\n        }\n        else{\n            fibonacci!($x-1) + fibonacci!($x-2);\n        }\n    };\n}\nfn main() {\n    fibonacci!(1);\n}\n</code></pre>"},{"location":"01-basics/04-macros/macro-plan/","title":"Macro Plan","text":"<p>That\u2019s an intense study session! \ud83d\ude80 You can definitely get very comfortable with Rust macros in that time if you focus smartly. Here's a roadmap to maximize your learning:</p>"},{"location":"01-basics/04-macros/macro-plan/#hour-1-2-basics-of-declarative-macros-macro_rules","title":"Hour 1-2: Basics of Declarative Macros (<code>macro_rules!</code>)","text":"<p>\u2705 Understand how <code>macro_rules!</code> works \u2705 Learn about patterns (<code>$expr</code>, <code>$ident</code>, <code>$tt</code>, <code>$block</code>) \u2705 Practice simple macros like <code>println!</code>, <code>vec!</code>, and custom ones  </p> <p>\ud83d\udd39 Exercises: - Write a macro that squares a number - Write a macro that repeats a string <code>n</code> times - Write a macro that creates a <code>HashMap</code> </p> <p>\ud83d\udcda Reference: - Rust Book - Macros</p>"},{"location":"01-basics/04-macros/macro-plan/#hour-3-4-intermediate-declarative-macros","title":"Hour 3-4: Intermediate Declarative Macros","text":"<p>\u2705 Handle multiple arguments \u2705 Use recursion inside macros \u2705 Use <code>tt</code> (token trees) for flexible macros \u2705 Debugging macros (<code>macro_rules!</code> pitfalls)</p> <p>\ud83d\udd39 Exercises: - Write a <code>min!</code> macro that finds the smallest of multiple numbers - Write a <code>log!</code> macro that prints with different log levels  </p> <p>\ud83d\udcda Reference: - Rust Reference - Macros</p>"},{"location":"01-basics/04-macros/macro-plan/#hour-5-6-introduction-to-procedural-macros","title":"Hour 5-6: Introduction to Procedural Macros","text":"<p>\u2705 Learn about <code>proc_macro</code> and <code>proc_macro2</code> crates \u2705 Understand function-like, derive, and attribute macros \u2705 Write a simple derive macro (e.g., <code>#[derive(Hello)]</code>)</p> <p>\ud83d\udd39 Exercises: - Create a custom derive macro that prints <code>\"Hello from struct!\"</code> - Write a procedural macro that converts a function into an async version  </p> <p>\ud83d\udcda Reference: - Rust Book - Procedural Macros - Rust API Docs - proc_macro</p>"},{"location":"01-basics/04-macros/macro-plan/#hour-7-8-advanced-procedural-macros","title":"Hour 7-8: Advanced Procedural Macros","text":"<p>\u2705 Work with <code>syn</code> and <code>quote</code> crates \u2705 Parse Rust syntax trees \u2705 Implement attribute-like macros (<code>#[my_macro]</code>)</p> <p>\ud83d\udd39 Exercises: - Implement a macro that adds logging to any function - Write a macro that converts function names to uppercase  </p> <p>\ud83d\udcda Reference: - Procedural Macros Workshop</p>"},{"location":"01-basics/04-macros/macro-plan/#hour-9-review-experiment-and-write-your-own-macros","title":"Hour 9: Review, Experiment, and Write Your Own Macros","text":"<p>\u2705 Revisit concepts \u2705 Implement your own creative macros \u2705 Debug and understand real-world macros (<code>serde</code>, <code>tokio::main</code>)</p>"},{"location":"01-basics/04-macros/macro-plan/#tips-for-staying-focused","title":"Tips for Staying Focused","text":"<p>\ud83d\udca1 Take short 5-minute breaks every hour \ud83d\udca1 Code along with examples instead of just reading \ud83d\udca1 Use <code>cargo expand</code> to see how macros expand  </p> <p>If you stick to this plan, you\u2019ll get really comfortable with Rust macros. \ud83d\udd25 Want help with a specific macro concept while working through this?</p>"},{"location":"02-library/01-standard-library/01-os/","title":"\ud83d\uddc2 Rust OS/File System Utilities","text":"<p>Uses from:</p> <pre><code>use std::fs;\nuse std::fs::{File, OpenOptions};\nuse std::io::{Read, Write};\nuse std::path::Path;\n</code></pre>"},{"location":"02-library/01-standard-library/01-os/#check-if-a-file-or-directory-exists","title":"\ud83d\udcc4 Check if a file or directory exists","text":"<pre><code>let path = Path::new(\"some_file.txt\");\n\nif path.exists() {\n    println!(\"File or directory exists!\");\n}\n</code></pre>"},{"location":"02-library/01-standard-library/01-os/#create-a-file-overwrite-if-exists","title":"\ud83c\udd95 Create a file (overwrite if exists)","text":"<pre><code>let mut file = File::create(\"hello.txt\")?;\nfile.write_all(b\"Hello, Rust!\")?;\n</code></pre> <p>Overwrites if file already exists.</p>"},{"location":"02-library/01-standard-library/01-os/#append-to-a-file-or-create-if-doesnt-exist","title":"\u2795 Append to a file (or create if doesn't exist)","text":"<pre><code>let mut file = OpenOptions::new()\n    .append(true)\n    .create(true)\n    .open(\"hello.txt\")?;\n\nfile.write_all(b\"\\nAppended line\")?;\n</code></pre>"},{"location":"02-library/01-standard-library/01-os/#read-a-file-whole-content-as-string","title":"\ud83d\udcd6 Read a file (whole content as String)","text":"<pre><code>let contents = fs::read_to_string(\"hello.txt\")?;\nprintln!(\"{}\", contents);\n</code></pre>"},{"location":"02-library/01-standard-library/01-os/#read-raw-bytes-from-a-file","title":"\ud83d\udd04 Read raw bytes from a file","text":"<pre><code>let bytes = fs::read(\"hello.txt\")?;\nprintln!(\"{:?}\", bytes);\n</code></pre>"},{"location":"02-library/01-standard-library/01-os/#delete-a-file","title":"\ud83d\uddd1 Delete a file","text":"<pre><code>fs::remove_file(\"hello.txt\")?;\n</code></pre>"},{"location":"02-library/01-standard-library/01-os/#create-a-directory","title":"\ud83d\udcc1 Create a directory","text":"<pre><code>fs::create_dir(\"my_folder\")?;\n</code></pre> <ul> <li>Recursive: <code>fs::create_dir_all(\"a/b/c\")?;</code></li> </ul>"},{"location":"02-library/01-standard-library/01-os/#delete-a-directory","title":"\ud83d\uddd1 Delete a directory","text":"<pre><code>fs::remove_dir(\"my_folder\")?;\n</code></pre> <ul> <li>Recursive delete: <code>fs::remove_dir_all(\"a/b\")?;</code></li> </ul>"},{"location":"02-library/01-standard-library/01-os/#list-files-in-a-directory","title":"\ud83d\udcdc List files in a directory","text":"<pre><code>for entry in fs::read_dir(\"some_folder\")? {\n    let entry = entry?;\n    println!(\"{:?} : {:?}\", entry.path(), entry.file_type().unwrap().is_file());\n}\n</code></pre>"},{"location":"02-library/01-standard-library/01-os/#summary-table","title":"\u2705 Summary Table","text":"Task Function / Method Check if file/dir exists <code>Path::exists()</code> Create (overwrite) file <code>File::create()</code> Append to file <code>OpenOptions::new().append(true)...</code> Read file as <code>String</code> <code>fs::read_to_string()</code> Read file as bytes <code>fs::read()</code> Write bytes to file <code>file.write_all(b\"...\")</code> Delete file <code>fs::remove_file()</code> Create directory <code>fs::create_dir()</code> / <code>create_dir_all()</code> Delete directory <code>fs::remove_dir()</code> / <code>remove_dir_all()</code> List dir entries <code>fs::read_dir()</code>"},{"location":"02-library/01-standard-library/02-time/","title":"\ud83d\udd52 Time in Rust","text":""},{"location":"02-library/01-standard-library/02-time/#from-the-standard-library-stdtime","title":"\u2705 From the Standard Library (<code>std::time</code>)","text":"<pre><code>use std::time::{SystemTime, UNIX_EPOCH, Duration};\n</code></pre>"},{"location":"02-library/01-standard-library/02-time/#get-current-system-time-as-unix-timestamp","title":"\u23f0 Get current system time (as UNIX timestamp)","text":"<pre><code>let now = SystemTime::now();\nlet since_epoch = now.duration_since(UNIX_EPOCH)?;\nprintln!(\"Seconds since epoch: {}\", since_epoch.as_secs());\n</code></pre>"},{"location":"02-library/01-standard-library/02-time/#measure-elapsed-time","title":"\ud83d\udd51 Measure elapsed time","text":"<pre><code>let start = std::time::Instant::now();\n\n// some computation\nstd::thread::sleep(Duration::from_secs(2));\n\nlet duration = start.elapsed();\nprintln!(\"Time elapsed: {:?}\", duration);\n</code></pre>"},{"location":"02-library/01-standard-library/02-time/#using-chrono-crate-recommended-for-more-flexibility","title":"\ud83e\udded Using <code>chrono</code> crate (Recommended for more flexibility)","text":"<p>Add to <code>Cargo.toml</code>:</p> <pre><code>chrono = \"0.4\"\n</code></pre> <pre><code>use chrono::{Local, Utc, Datelike, Timelike};\n</code></pre>"},{"location":"02-library/01-standard-library/02-time/#get-current-datetime","title":"\ud83d\udcc6 Get current date/time","text":"<pre><code>let now = Local::now(); // or Utc::now()\nprintln!(\"Local: {}\", now);\n</code></pre>"},{"location":"02-library/01-standard-library/02-time/#access-parts","title":"\ud83e\udde9 Access parts","text":"<pre><code>println!(\n    \"{}-{:02}-{:02} {}:{:02}:{:02}\",\n    now.year(),\n    now.month(),\n    now.day(),\n    now.hour(),\n    now.minute(),\n    now.second(),\n);\n</code></pre>"},{"location":"02-library/01-standard-library/02-time/#parse-and-format-dates","title":"\ud83d\udcc5 Parse and format dates","text":"<pre><code>use chrono::NaiveDateTime;\n\nlet dt = NaiveDateTime::parse_from_str(\"2025-06-01 14:30:00\", \"%Y-%m-%d %H:%M:%S\")?;\nprintln!(\"Parsed datetime: {}\", dt);\n\nlet formatted = now.format(\"%Y-%m-%d %H:%M:%S\").to_string();\nprintln!(\"Formatted: {}\", formatted);\n</code></pre>"},{"location":"02-library/01-standard-library/02-time/#summary-table","title":"\u2705 Summary Table","text":"Task <code>std::time</code> <code>chrono</code> Get current time <code>SystemTime::now()</code> <code>Local::now()</code> / <code>Utc::now()</code> Time since epoch <code>duration_since(...)</code> <code>timestamp()</code> Measure elapsed time <code>Instant::now().elapsed()</code> <code>Utc::now() - other_time</code> Formatting / Parsing \u274c (Manual only) \u2705 Built-in with <code>format()</code> Date math (add/sub) Manual with <code>Duration</code> Easy with <code>+/-</code> and <code>Duration</code>"},{"location":"02-library/01-standard-library/03-env-variable/","title":"\ud83c\udf31 Rust Environment Variables (<code>std::env</code>)","text":"<p>The <code>std::env</code> module allows interacting with the environment at runtime: reading, setting, modifying env vars, accessing CLI args, current dir, etc.</p>"},{"location":"02-library/01-standard-library/03-env-variable/#get-environment-variable","title":"\u2705 Get Environment Variable","text":"<pre><code>use std::env;\n\nfn main() {\n    // Returns Result&lt;String, VarError&gt;\n    match env::var(\"HOME\") {\n        Ok(val) =&gt; println!(\"HOME: {}\", val),\n        Err(e) =&gt; println!(\"Couldn't read HOME: {}\", e),\n    }\n}\n</code></pre>"},{"location":"02-library/01-standard-library/03-env-variable/#handle-missing-env-var-gracefully","title":"\u274c Handle Missing Env Var Gracefully","text":"<pre><code>let path = env::var(\"MY_CONFIG_PATH\").unwrap_or(\"default/path\".to_string());\n</code></pre>"},{"location":"02-library/01-standard-library/03-env-variable/#set-an-env-var","title":"\ud83d\udd27 Set an Env Var","text":"<p>Only lasts during the current process lifetime</p> <pre><code>env::set_var(\"MY_KEY\", \"my_value\");\nprintln!(\"{}\", env::var(\"MY_KEY\").unwrap()); // prints \"my_value\"\n</code></pre>"},{"location":"02-library/01-standard-library/03-env-variable/#remove-an-env-var","title":"\ud83d\udeab Remove an Env Var","text":"<pre><code>env::remove_var(\"MY_KEY\");\n</code></pre>"},{"location":"02-library/01-standard-library/03-env-variable/#list-all-env-vars","title":"\ud83d\udcdc List All Env Vars","text":"<pre><code>for (key, value) in env::vars() {\n    println!(\"{key} = {value}\");\n}\n</code></pre>"},{"location":"02-library/01-standard-library/03-env-variable/#read-cli-args","title":"\ud83e\uddfe Read CLI Args","text":"<pre><code>fn main() {\n    for arg in env::args() {\n        println!(\"{}\", arg);\n    }\n}\n</code></pre>"},{"location":"02-library/01-standard-library/03-env-variable/#get-current-directory","title":"\ud83d\udcc2 Get Current Directory","text":"<pre><code>let path = env::current_dir().unwrap();\nprintln!(\"Current dir: {}\", path.display());\n</code></pre>"},{"location":"02-library/01-standard-library/03-env-variable/#set-current-directory","title":"\ud83d\udd01 Set Current Directory","text":"<pre><code>env::set_current_dir(\"/tmp\").expect(\"Failed to change directory\");\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/","title":"Tokio Notes","text":""},{"location":"02-library/02-external-library/04-tokio/#1-introduction-to-tokio","title":"1. Introduction to Tokio","text":"<p>Tokio is an asynchronous runtime for Rust, designed for building fast and reliable network applications. It provides async/await support, efficient task scheduling, and various utilities for working with async operations.</p> <p>In async rust, it has a future trait, that implements poll method, and has two values done and pending. </p>"},{"location":"02-library/02-external-library/04-tokio/#2-setting-up-tokio","title":"2. Setting Up Tokio","text":"<p>To use Tokio in your Rust project, add the following to <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\ntokio = { version = \"1\", features = [\"full\"] }\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#3-basic-async-runtime","title":"3. Basic Async Runtime","text":"<p>A Tokio async main function must be annotated with <code>#[tokio::main]</code>:</p> <pre><code>#[tokio::main]\nasync fn main() {\n    println!(\"Hello from Tokio!\");\n}\n</code></pre> <p>Alternatively, you can manually create a runtime:</p> <pre><code>fn main() {\n    let rt = tokio::runtime::Runtime::new().unwrap();\n    rt.block_on(async {\n        println!(\"Manually managed runtime\");\n    });\n}\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#4-spawning-async-tasks","title":"4. Spawning Async Tasks","text":"<pre><code>#[tokio::main]\nasync fn main() {\n    tokio::spawn(async {\n        println!(\"Running in the background!\");\n    });\n}\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#5-async-sleep","title":"5. Async Sleep","text":"<pre><code>use tokio::time::{sleep, Duration};\n\n#[tokio::main]\nasync fn main() {\n    println!(\"Sleeping for 2 seconds...\");\n    sleep(Duration::from_secs(2)).await;\n    println!(\"Awake now!\");\n}\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#6-using-tokio-channels","title":"6. Using Tokio Channels","text":"<p>Tokio provides async channels for communication between tasks:</p> <pre><code>use tokio::sync::mpsc;\n\n#[tokio::main]\nasync fn main() {\n    let (tx, mut rx) = mpsc::channel(32);\n\n    tokio::spawn(async move {\n        tx.send(\"Hello from task\").await.unwrap();\n    });\n\n    let msg = rx.recv().await.unwrap();\n    println!(\"Received: {msg}\");\n}\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#7-handling-concurrency-with-join","title":"7. Handling Concurrency with Join","text":"<pre><code>async fn task1() {\n    println!(\"Task 1\");\n}\nasync fn task2() {\n    println!(\"Task 2\");\n}\n\n#[tokio::main]\nasync fn main() {\n    tokio::join!(task1(), task2());\n}\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#8-using-tokio-mutex","title":"8. Using Tokio Mutex","text":"<pre><code>use std::sync::Arc;\nuse tokio::sync::Mutex;\n\n#[tokio::main]\nasync fn main() {\n    let data = Arc::new(Mutex::new(0));\n\n    let data_cloned = data.clone();\n    tokio::spawn(async move {\n        let mut num = data_cloned.lock().await;\n        *num += 1;\n    }).await.unwrap();\n\n    println!(\"Final value: {}\", *data.lock().await);\n}\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#9-streaming-with-tokio","title":"9. Streaming with Tokio","text":"<pre><code>use tokio::sync::mpsc;\nuse tokio_stream::StreamExt;\n\n#[tokio::main]\nasync fn main() {\n    let (tx, rx) = mpsc::channel(32);\n    let mut stream = tokio_stream::wrappers::ReceiverStream::new(rx);\n\n    tokio::spawn(async move {\n        tx.send(42).await.unwrap();\n    });\n\n    while let Some(value) = stream.next().await {\n        println!(\"Received: {value}\");\n    }\n}\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#10-using-tokio-with-http-reqwest","title":"10. Using Tokio with HTTP (reqwest)","text":"<pre><code>use reqwest;\n\n#[tokio::main]\nasync fn main() {\n    let resp = reqwest::get(\"https://api.github.com/repos/tokio-rs/tokio\")\n        .await\n        .unwrap()\n        .text()\n        .await\n        .unwrap();\n    println!(\"Response: {resp}\");\n}\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#11-using-tokio-runtime-without-tokiomain","title":"11. Using Tokio Runtime Without <code>#[tokio::main]</code>","text":"<pre><code>use tokio::runtime::Runtime;\n\nfn main() {\n    let rt = Runtime::new().unwrap();\n    rt.block_on(async {\n        println!(\"Using Tokio without #[tokio::main]\");\n    });\n}\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#12-tokio-file-io-with-async-readwrite","title":"12. Tokio File IO with Async Read/Write","text":"<pre><code>use tokio::fs::File;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\n\n#[tokio::main]\nasync fn main() -&gt; std::io::Result&lt;()&gt; {\n    let mut file = File::create(\"test.txt\").await?;\n    file.write_all(b\"Hello, Tokio!\").await?;\n\n    let mut file = File::open(\"test.txt\").await?;\n    let mut contents = vec![];\n    file.read_to_end(&amp;mut contents).await?;\n    println!(\"File contents: {:?}\", String::from_utf8_lossy(&amp;contents));\n\n    Ok(())\n}\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#13-tokio-tasks-with-timeouts","title":"13. Tokio Tasks with Timeouts","text":"<pre><code>use tokio::time::{timeout, Duration};\n\n#[tokio::main]\nasync fn main() {\n    let result = timeout(Duration::from_secs(2), async {\n        tokio::time::sleep(Duration::from_secs(3)).await;\n        \"Completed\"\n    }).await;\n\n    match result {\n        Ok(val) =&gt; println!(\"Task finished: {val}\"),\n        Err(_) =&gt; println!(\"Task timed out\"),\n    }\n}\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#14-tokio-signal-handling","title":"14. Tokio Signal Handling","text":"<pre><code>use tokio::signal;\n\n#[tokio::main]\nasync fn main() {\n    println!(\"Press Ctrl+C to exit\");\n    signal::ctrl_c().await.unwrap();\n    println!(\"Shutting down\");\n}\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#15-tokio-thread-pool","title":"15. Tokio Thread Pool","text":"<pre><code>use tokio::runtime::Builder;\n\nfn main() {\n    let rt = Builder::new_multi_thread()\n        .worker_threads(4)\n        .enable_all()\n        .build()\n        .unwrap();\n    rt.block_on(async {\n        println!(\"Using a multi-threaded Tokio runtime\");\n    });\n}\n</code></pre>"},{"location":"02-library/02-external-library/04-tokio/#a-good-example","title":"A good example","text":"<pre><code>use tokio::time::{sleep, Duration};\nuse futures::future::join_all;\n\nfn main() {\n    let rt = tokio::runtime::Runtime::new().unwrap();\n    let mut workers: Vec&lt;tokio::task::JoinHandle&lt;()&gt;&gt; = Vec::new();\n    for i in 0..2 {\n        let w = rt.spawn(worker(i));\n        workers.push(w);\n    }\n\n    separator();\n    // Wait for all workers to complete\n    rt.block_on(async {\n        join_all(workers).await;\n    });\n\n    separator();\n\n    println!(\"All done. Bye bye!\");\n}\n\nasync fn worker(id: u32) {\n    for i in 1..100 {\n        println!(\"Worker-{id} is working on idx-{i}\");\n        sleep(Duration::from_millis(10)).await;\n    }\n}\n\nfn separator(){\n    let sep = String::from(\"=\").repeat(50);\n    println!(\"{sep}\");\n}\n</code></pre>"},{"location":"02-library/02-external-library/05-futures/","title":"Futures Notes","text":""},{"location":"02-library/02-external-library/05-futures/#1-introduction-to-futures","title":"1. Introduction to Futures","text":"<p>The <code>futures</code> crate provides abstractions for asynchronous programming in Rust. It extends the standard library's <code>Future</code> trait with additional combinators, utilities, and runtime-independent async features.</p>"},{"location":"02-library/02-external-library/05-futures/#2-adding-futures-to-cargotoml","title":"2. Adding Futures to Cargo.toml","text":"<pre><code>[dependencies]\nfutures = \"0.3\"\n</code></pre> <p>Then, run <code>cargo build</code>.</p>"},{"location":"02-library/02-external-library/05-futures/#3-basic-future-example","title":"3. Basic Future Example","text":"<pre><code>use futures::executor::block_on;\n\nasync fn hello() {\n    println!(\"Hello, Future!\");\n}\n\nfn main() {\n    block_on(hello());\n}\n</code></pre>"},{"location":"02-library/02-external-library/05-futures/#4-using-futurepoll","title":"4. Using <code>Future::poll</code>","text":"<pre><code>use futures::future::Future;\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\nstruct MyFuture;\n\nimpl Future for MyFuture {\n    type Output = i32;\n\n    fn poll(self: Pin&lt;&amp;mut Self&gt;, _cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {\n        Poll::Ready(42)\n    }\n}\n\nfn main() {\n    let mut future = MyFuture;\n    let waker = futures::task::noop_waker();\n    let mut context = Context::from_waker(&amp;waker);\n\n    match Pin::new(&amp;mut future).poll(&amp;mut context) {\n        Poll::Ready(value) =&gt; println!(\"Future ready with value: {}\", value),\n        Poll::Pending =&gt; println!(\"Future pending\"),\n    }\n}\n</code></pre>"},{"location":"02-library/02-external-library/05-futures/#5-combining-futures-with-join","title":"5. Combining Futures with <code>join!</code>","text":"<pre><code>use futures::join;\n\nasync fn async_task1() -&gt; i32 {\n    1\n}\nasync fn async_task2() -&gt; i32 {\n    2\n}\n\n#[tokio::main]\nasync fn main() {\n    let (a, b) = join!(async_task1(), async_task2());\n    println!(\"Results: {}, {}\", a, b);\n}\n</code></pre>"},{"location":"02-library/02-external-library/05-futures/#6-chaining-with-then-and-map","title":"6. Chaining with <code>then</code> and <code>map</code>","text":"<pre><code>use futures::future::ready;\nuse futures::FutureExt;\n\n#[tokio::main]\nasync fn main() {\n    let fut = ready(10).map(|x| x * 2);\n    println!(\"Result: {}\", fut.await);\n}\n</code></pre>"},{"location":"02-library/02-external-library/05-futures/#7-using-select-for-race-conditions","title":"7. Using <code>select!</code> for Race Conditions","text":"<pre><code>use futures::future::{ready, pending};\nuse futures::select;\n\n#[tokio::main]\nasync fn main() {\n    let a = ready(\"Task A done\");\n    let b = pending::&lt;&amp;str&gt;();\n\n    select! {\n        result = a =&gt; println!(\"First completed: {}\", result),\n        result = b =&gt; println!(\"Second completed: {}\", result),\n    }\n}\n</code></pre>"},{"location":"02-library/02-external-library/05-futures/#8-streams-with-futuresstream","title":"8. Streams with <code>futures::stream</code>","text":"<pre><code>use futures::stream::{self, StreamExt};\n\n#[tokio::main]\nasync fn main() {\n    let mut stream = stream::iter(vec![1, 2, 3]);\n\n    while let Some(value) = stream.next().await {\n        println!(\"Received: {}\", value);\n    }\n}\n</code></pre>"},{"location":"02-library/02-external-library/05-futures/#9-buffered-concurrency-with-buffer_unordered","title":"9. Buffered Concurrency with <code>buffer_unordered</code>","text":"<pre><code>use futures::stream::{self, StreamExt};\nuse futures::future;\n\n#[tokio::main]\nasync fn main() {\n    let tasks = stream::iter(vec![1, 2, 3])\n        .map(|num| async move {\n            println!(\"Processing {}\", num);\n            num * 2\n        })\n        .buffer_unordered(2);\n\n    tasks.for_each(|result| async move {\n        println!(\"Completed: {}\", result);\n    }).await;\n}\n</code></pre>"},{"location":"02-library/02-external-library/05-futures/#10-using-futureschannelmpsc","title":"10. Using <code>futures::channel::mpsc</code>","text":"<pre><code>use futures::channel::mpsc;\nuse futures::sink::SinkExt;\nuse futures::stream::StreamExt;\n\n#[tokio::main]\nasync fn main() {\n    let (mut tx, mut rx) = mpsc::channel(10);\n\n    tokio::spawn(async move {\n        tx.send(\"Message\").await.unwrap();\n    });\n\n    while let Some(msg) = rx.next().await {\n        println!(\"Received: {}\", msg);\n    }\n}\n</code></pre>"},{"location":"02-library/02-external-library/07-pyo3/","title":"PyO3 Notes","text":""},{"location":"02-library/02-external-library/07-pyo3/#1-introduction-to-pyo3","title":"1. Introduction to PyO3","text":"<p>PyO3 allows Rust code to interface with Python, enabling the creation of Python modules and embedding Python in Rust applications. It provides Rust bindings for the Python C API.</p>"},{"location":"02-library/02-external-library/07-pyo3/#2-setting-up-pyo3","title":"2. Setting Up PyO3","text":"<p>To use PyO3, add the following to <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\npyo3 = { version = \"0.20\", features = [\"extension-module\"] }\n</code></pre> <p>For a binary application embedding Python:</p> <pre><code>[dependencies]\npyo3 = { version = \"0.20\" }\n</code></pre> <p>Enable the <code>extension-module</code> feature only when building a Python extension.</p>"},{"location":"02-library/02-external-library/07-pyo3/#3-creating-a-python-module-in-rust","title":"3. Creating a Python Module in Rust","text":"<p>Create a Rust library and add <code>lib.rs</code>:</p> <pre><code>use pyo3::prelude::*;\n\n#[pyfunction]\nfn add(a: i32, b: i32) -&gt; PyResult&lt;i32&gt; {\n    Ok(a + b)\n}\n\n#[pymodule]\nfn mymodule(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {\n    m.add_function(wrap_pyfunction!(add, m)?)?;\n    Ok(())\n}\n</code></pre> <p>Compile it to a Python module using <code>maturin</code>:</p> <pre><code>maturin develop\n</code></pre> <p>Then use it in Python:</p> <pre><code>import mymodule\nprint(mymodule.add(2, 3))\n</code></pre>"},{"location":"02-library/02-external-library/07-pyo3/#4-working-with-python-objects-in-rust","title":"4. Working with Python Objects in Rust","text":"<pre><code>use pyo3::types::PyDict;\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn create_dict(py: Python) -&gt; PyResult&lt;PyObject&gt; {\n    let dict = PyDict::new(py);\n    dict.set_item(\"key\", \"value\")?;\n    Ok(dict.into())\n}\n</code></pre>"},{"location":"02-library/02-external-library/07-pyo3/#5-calling-python-from-rust","title":"5. Calling Python from Rust","text":"<pre><code>use pyo3::prelude::*;\n\nfn main() {\n    Python::with_gil(|py| {\n        let sys = py.import(\"sys\").unwrap();\n        let version: String = sys.getattr(\"version\").unwrap().extract().unwrap();\n        println!(\"Python version: {}\", version);\n    });\n}\n</code></pre>"},{"location":"02-library/02-external-library/07-pyo3/#6-using-rust-structs-in-python","title":"6. Using Rust Structs in Python","text":"<pre><code>use pyo3::prelude::*;\n\n#[pyclass]\nstruct Person {\n    #[pyo3(get, set)]\n    name: String,\n}\n\n#[pymethods]\nimpl Person {\n    #[new]\n    fn new(name: String) -&gt; Self {\n        Person { name }\n    }\n}\n\n#[pymodule]\nfn mymodule(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {\n    m.add_class::&lt;Person&gt;()?;\n    Ok(())\n}\n</code></pre>"},{"location":"02-library/02-external-library/07-pyo3/#7-handling-python-exceptions-in-rust","title":"7. Handling Python Exceptions in Rust","text":"<pre><code>use pyo3::exceptions::PyValueError;\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn fail() -&gt; PyResult&lt;()&gt; {\n    Err(PyValueError::new_err(\"An error occurred\"))\n}\n</code></pre>"},{"location":"02-library/02-external-library/07-pyo3/#8-embedding-python-in-a-rust-binary","title":"8. Embedding Python in a Rust Binary","text":"<pre><code>use pyo3::prelude::*;\n\nfn main() {\n    Python::with_gil(|py| {\n        let locals = [(\"x\", 5)].into_py_dict(py);\n        py.run(\"print(x * 2)\", None, Some(&amp;locals)).unwrap();\n    });\n}\n</code></pre>"},{"location":"02-library/02-external-library/07-pyo3/#9-async-python-with-tokio-and-pyo3","title":"9. Async Python with Tokio and PyO3","text":"<pre><code>use pyo3::prelude::*;\nuse pyo3_asyncio::tokio::future_into_py;\nuse tokio::time::{sleep, Duration};\n\n#[pyfunction]\nfn async_function(py: Python) -&gt; PyResult&lt;PyObject&gt; {\n    future_into_py(py, async move {\n        sleep(Duration::from_secs(2)).await;\n        Ok(\"Done!\")\n    })\n}\n</code></pre>"},{"location":"02-library/02-external-library/07-pyo3/#10-compiling-and-using-pyo3-modules","title":"10. Compiling and Using PyO3 Modules","text":"<ul> <li>Build the module: <code>maturin build</code></li> <li>Install locally: <code>maturin develop</code></li> <li>Run in Python: <code>import mymodule</code></li> </ul>"},{"location":"02-library/02-external-library/08-rayon/","title":"Rayon Notes","text":""},{"location":"02-library/02-external-library/08-rayon/#1-introduction-to-rayon","title":"1. Introduction to Rayon","text":"<p>Rayon is a Rust library that provides an easy way to parallelize computations using data parallelism. It works by converting standard iterators into parallel iterators.</p>"},{"location":"02-library/02-external-library/08-rayon/#2-setting-up-rayon","title":"2. Setting Up Rayon","text":"<p>To use Rayon, add it to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nrayon = \"1\"\n</code></pre>"},{"location":"02-library/02-external-library/08-rayon/#3-converting-iterators-to-parallel-iterators","title":"3. Converting Iterators to Parallel Iterators","text":"<p>Rayon provides <code>par_iter()</code> to turn an iterator into a parallel iterator.</p> <pre><code>use rayon::prelude::*;\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5];\n    let squares: Vec&lt;_&gt; = nums.par_iter().map(|x| x * x).collect();\n    println!(\"{:?}\", squares);\n}\n</code></pre>"},{"location":"02-library/02-external-library/08-rayon/#4-parallel-for-each","title":"4. Parallel For-Each","text":"<p>Use <code>par_iter().for_each()</code> to process items in parallel without collecting results.</p> <pre><code>use rayon::prelude::*;\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5];\n    nums.par_iter().for_each(|x| println!(\"Processing: {}\", x));\n}\n</code></pre>"},{"location":"02-library/02-external-library/08-rayon/#5-parallel-sorting","title":"5. Parallel Sorting","text":"<p>Rayon provides parallel sorting with <code>par_sort()</code> and <code>par_sort_unstable()</code>.</p> <pre><code>use rayon::prelude::*;\n\nfn main() {\n    let mut nums = vec![5, 3, 1, 4, 2];\n    nums.par_sort();\n    println!(\"{:?}\", nums);\n}\n</code></pre>"},{"location":"02-library/02-external-library/08-rayon/#6-parallel-filtering","title":"6. Parallel Filtering","text":"<p>Parallel filtering with <code>par_filter()</code>.</p> <pre><code>use rayon::prelude::*;\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5, 6];\n    let even_nums: Vec&lt;_&gt; = nums.par_iter().filter(|&amp;&amp;x| x % 2 == 0).collect();\n    println!(\"{:?}\", even_nums);\n}\n</code></pre>"},{"location":"02-library/02-external-library/08-rayon/#7-parallel-reduction","title":"7. Parallel Reduction","text":"<p>Use <code>reduce()</code> to perform reductions in parallel.</p> <pre><code>use rayon::prelude::*;\n\nfn main() {\n    let nums = vec![1, 2, 3, 4, 5];\n    let sum = nums.par_iter().cloned().reduce(|| 0, |a, b| a + b);\n    println!(\"Sum: {}\", sum);\n}\n</code></pre>"},{"location":"02-library/02-external-library/08-rayon/#8-parallelizing-custom-collections","title":"8. Parallelizing Custom Collections","text":"<p>To enable parallel iteration on custom collections, implement <code>IntoParallelIterator</code>.</p> <pre><code>use rayon::prelude::*;\nuse std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"a\", 1);\n    map.insert(\"b\", 2);\n    map.insert(\"c\", 3);\n\n    map.par_iter().for_each(|(k, v)| {\n        println!(\"Key: {}, Value: {}\", k, v);\n    });\n}\n</code></pre>"},{"location":"02-library/02-external-library/08-rayon/#9-using-par_bridge-for-non-rayon-iterators","title":"9. Using <code>par_bridge()</code> for Non-Rayon Iterators","text":"<p>If an iterator does not implement <code>ParallelIterator</code>, you can convert it using <code>par_bridge()</code>.</p> <pre><code>use rayon::prelude::*;\n\nfn main() {\n    let nums = (0..10).into_iter().par_bridge().map(|x| x * 2).collect::&lt;Vec&lt;_&gt;&gt;();\n    println!(\"{:?}\", nums);\n}\n</code></pre>"},{"location":"02-library/02-external-library/08-rayon/#10-controlling-thread-pool","title":"10. Controlling Thread Pool","text":"<p>Use <code>rayon::ThreadPoolBuilder</code> to customize thread pool settings.</p> <pre><code>use rayon::ThreadPoolBuilder;\n\nfn main() {\n    let pool = ThreadPoolBuilder::new().num_threads(4).build().unwrap();\n    pool.install(|| {\n        let sum: i32 = (1..10).into_par_iter().sum();\n        println!(\"Sum: {}\", sum);\n    });\n}\n</code></pre>"},{"location":"02-library/02-external-library/async/","title":"Async","text":"<p>In async Rust, the execution of asynchronous tasks is driven by the <code>Future</code> trait, which is at the core of Rust's async model. Here\u2019s a complete and corrected explanation:</p>"},{"location":"02-library/02-external-library/async/#the-future-trait","title":"The <code>Future</code> Trait","text":"<p>The <code>Future</code> trait represents a computation that might not have completed yet but will produce a value at some point. It is defined as:</p> <pre><code>trait Future {\n    type Output;\n    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;\n}\n</code></pre>"},{"location":"02-library/02-external-library/async/#how-poll-works","title":"How <code>poll</code> Works","text":"<ul> <li>The poll method is the key mechanism in Rust's async system.</li> <li>It is not called automatically; instead, an executor calls it.</li> <li><code>poll</code> takes a pinned mutable reference (<code>Pin&lt;&amp;mut Self&gt;</code>) to the future.</li> <li>It also takes a context (<code>&amp;mut Context&lt;'_&gt;</code>), which provides a way to register wakers.</li> </ul>"},{"location":"02-library/02-external-library/async/#return-values-of-poll","title":"Return Values of <code>poll</code>","text":"<p><code>poll</code> returns a <code>Poll&lt;T&gt;</code>, which can be: 1. <code>Poll::Pending</code> \u2192 The future is not ready yet, but the executor should call <code>poll</code> again later. 2. <code>Poll::Ready(output)</code> \u2192 The future is done, and it returns the computed value.</p>"},{"location":"02-library/02-external-library/async/#who-calls-poll","title":"Who Calls <code>poll</code>?","text":"<ul> <li>Futures do not start automatically when created.</li> <li>They are lazy, meaning <code>poll</code> is only called when:</li> <li>The future is awaited.</li> <li>The future is polled manually by an executor.</li> </ul>"},{"location":"02-library/02-external-library/async/#wakers-and-context","title":"Wakers and <code>Context</code>","text":"<p>When a future returns <code>Poll::Pending</code>, it must register a waker inside <code>Context</code>. The waker tells the executor when the future is ready to be polled again.</p>"},{"location":"02-library/02-external-library/async/#how-async-functions-work","title":"How <code>async</code> Functions Work","text":"<p>When you write an <code>async fn</code>, the Rust compiler: 1. Transforms it into a state machine that implements <code>Future</code>. 2. Calls <code>poll</code> whenever needed until completion.</p>"},{"location":"02-library/02-external-library/async/#example-implementing-a-custom-future","title":"Example: Implementing a Custom Future","text":"<p>Here\u2019s a simple example of implementing a manual Future:</p> <pre><code>use std::{\n    pin::Pin,\n    task::{Context, Poll},\n    time::Instant,\n};\nuse tokio::time::sleep;\nuse std::future::Future;\n\nstruct Delay {\n    when: Instant,\n}\n\nimpl Future for Delay {\n    type Output = ();\n\n    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {\n        if Instant::now() &gt;= self.when {\n            Poll::Ready(())\n        } else {\n            cx.waker().wake_by_ref(); // Re-schedule the future\n            Poll::Pending\n        }\n    }\n}\n</code></pre>"},{"location":"02-library/02-external-library/async/#summary","title":"Summary","text":"<ul> <li><code>Future</code> is a trait with a <code>poll</code> method.</li> <li><code>poll</code> is called by the executor, not automatically.</li> <li>It returns <code>Poll::Pending</code> (if not done) or <code>Poll::Ready(value)</code>.</li> <li>If <code>Pending</code>, a waker must be registered to resume execution later.</li> <li><code>async</code> functions are state machines that implement <code>Future</code> automatically.</li> </ul> <p>Let me know if you want a deeper breakdown of any part! \ud83d\ude80</p>"},{"location":"02-library/03-utils-library/00-rand/","title":"\ud83d\udccc Rust <code>rand</code> Cheat Sheet","text":"<p>The <code>rand</code> crate provides random number generation, including secure RNGs, seeding, distributions, and shuffling.</p>"},{"location":"02-library/03-utils-library/00-rand/#installation","title":"\ud83d\udce6 Installation","text":"<ul> <li>Add <code>rand</code> to <code>Cargo.toml</code></li> </ul> <pre><code>[dependencies]\nrand = \"0.8\"\n</code></pre> <p>or,</p> <ul> <li>Run commannd:</li> </ul> <pre><code>cargo add rand\n</code></pre>"},{"location":"02-library/03-utils-library/00-rand/#1-basic-random-number-char-generation","title":"1\ufe0f\u20e3 Basic Random Number &amp; Char Generation","text":"<pre><code>use rand::random;\nuse rand::Rng;\n\nfn main() {\n    let random_u8: u8 = random(); // Generates a random u8\n    let random_bool: bool = random(); // Generates a random bool\n    let random_float: f32 = random(); // Generates a random float\n\n    println!(\"Random u8: {}\", random_u8);\n    println!(\"Random bool: {}\", random_bool);\n    println!(\"Random float: {}\", random_float);\n\n    // Get an RNG:\n    let mut rng = rand::rng();\n\n    // Try printing a random unicode code point (probably a bad idea)!\n    println!(\"char: '{}'\", rng.random::&lt;char&gt;());\n    // Try printing a random alphanumeric value instead!\n    println!(\"alpha: '{}'\", rng.sample(rand::distr::Alphanumeric) as char);\n}\n</code></pre> Method Description <code>random::&lt;T&gt;()</code> Generates a random value of type <code>T</code>"},{"location":"02-library/03-utils-library/00-rand/#2-using-a-random-number-generator-rng","title":"2\ufe0f\u20e3 Using a Random Number Generator (RNG)","text":"<pre><code>use rand::Rng;\n\nfn main() {\n    let mut rng = rand::rng(); // Get the thread-local RNG\n\n    let num: i32 = rng.random(); // Random i32\n    let num_range: i32 = rng.random_range(1..=100); // Random i32 in range 1-100\n    let float_range: f32 = rng.random_range(5.5..=7.5); // Random f32 in range 5.5-7.5\n\n    println!(\"Random i32: {}\", num);\n    println!(\"Random i32 in range 1-100: {}\", num_range);\n    println!(\"Random i32 in range 5.5-7.5: {}\", float_range);\n}\n</code></pre> <p>Note</p> <p>The above code in section:1 is just a shorthand for <code>rng.random</code> (section:2).</p> Method Description <code>.gen::&lt;T&gt;()</code> Generates a random value of type <code>T</code> <code>.gen_range(a..b)</code> Generates a number in range <code>[a, b)</code> <code>.gen_range(a..=b)</code> Generates a number in range <code>[a, b]</code>"},{"location":"02-library/03-utils-library/00-rand/#3-random-choice-from-a-list","title":"3\ufe0f\u20e3 Random Choice from a List","text":"<pre><code>use rand::seq::IndexedRandom;\n\nfn main() {\n    let choices = [\"\ud83c\udf4e\", \"\ud83c\udf4c\", \"\ud83c\udf4a\", \"\ud83c\udf49\"];\n    let mut rng = rand::rng();\n\n    for _ in 1..10 {\n        if let Some(random_fruit) = choices.choose(&amp;mut rng) {\n            println!(\"Random fruit: {}\", random_fruit);\n        }\n    }\n\n    println!(\"============\");\n    let my_choices = choices.choose_multiple(&amp;mut rng, 3);\n    for f in my_choices {\n        println!(\"{f}\")\n    }\n}\n</code></pre> Method Description <code>.choose(&amp;mut rng)</code> Picks a random element from a slice <code>.choose_multiple(&amp;mut rng, amount: usize)</code> Picks multiple random element from a slice"},{"location":"02-library/03-utils-library/00-rand/#4-shuffling-a-list","title":"4\ufe0f\u20e3 Shuffling a List","text":"<pre><code>use rand::seq::SliceRandom;\n\nfn main() {\n    let mut choices = [\"\ud83c\udf4e\", \"\ud83c\udf4c\", \"\ud83c\udf4a\", \"\ud83c\udf49\"];\n    let mut rng = rand::rng();\n\n    for _ in 1..5 {\n        choices.shuffle(&amp;mut rng);\n\n        println!(\"{choices:?}\");\n        println!(\"=======\");\n    }\n}\n</code></pre> Method Description <code>.shuffle(&amp;mut rng)</code> Shuffles elements in-place"},{"location":"02-library/03-utils-library/00-rand/#5-randomly-sampling-elements","title":"5\ufe0f\u20e3 Randomly Sampling Elements","text":"<ul> <li>Pick 3 unique indices from range 0-9.</li> </ul> <pre><code>use rand::seq::index::sample;\n\nfn main() {\n    let mut rng = rand::rng();\n    let indices = sample(&amp;mut rng, 10, 3); // Pick 3 unique indices from range 0-9\n\n    println!(\"Random indices: {:?}\", indices.into_iter().collect::&lt;Vec&lt;_&gt;&gt;());\n}\n</code></pre> Method Description <code>.sample(&amp;mut rng, total, count)</code> Selects <code>count</code> unique elements from <code>total</code>"},{"location":"02-library/03-utils-library/00-rand/#6-using-a-seeded-rng-for-reproducibility","title":"6\ufe0f\u20e3 Using a Seeded RNG for Reproducibility","text":"<pre><code>use rand::rngs::StdRng;\nuse rand::{Rng, SeedableRng};\n\nfn main() {\n    let seed = [42; 32]; // A fixed seed (must be 32 bytes)\n    let mut rng = StdRng::from_seed(seed);\n\n    println!(\"Seeded random number: {}\", rng.random::&lt;u32&gt;());\n    println!(\"Seeded random number: {}\", rng.random::&lt;u32&gt;());\n    println!(\"Seeded random number: {}\", rng.random::&lt;u32&gt;());\n}\n</code></pre> <ul> <li>Everytime you run this executable, the generated random number in each run will be same following the order.</li> </ul> Method Description <code>.from_seed(seed)</code> Creates a seeded RNG"},{"location":"02-library/03-utils-library/00-rand/#7-random-boolean-generation","title":"7\ufe0f\u20e3 Random Boolean Generation","text":"<ul> <li>Return a bool with a probability p of being true.</li> </ul> <pre><code>use rand;\nfn main() {\n\n    let mut count: u32 = 0;\n    for _ in 1..100{\n        let guess = rand::random_bool(0.3);\n\n        println!(\"Random guess is: {guess}\");\n        if guess{\n            count+=1;\n        }\n    }\n    println!(\"Got it correct for: {count} out of 100.\")\n}\n</code></pre> Method Description <code>.random_bool(p)</code> Returns <code>true</code> with probability <code>p</code>"},{"location":"02-library/03-utils-library/00-rand/#8-custom-probability-distributions","title":"8\ufe0f\u20e3 Custom Probability Distributions","text":"<pre><code>use rand::distr::{Bernoulli, Distribution};\n\nfn main() {\n    let mut rng = rand::rng();\n    let bernoulli_experiment = Bernoulli::new(0.34).unwrap();\n\n    for _ in 1..6 {\n        let random_value = bernoulli_experiment.sample(&amp;mut rng);\n\n        println!(\"Bernoulli experiment random value: {}\", random_value);\n    }\n}\n</code></pre> Method Description <code>Bernoulli::new(mean, std_dev)</code> Creates a Bernoulli distribution <code>.sample(&amp;mut rng)</code> Generates a sample"},{"location":"02-library/03-utils-library/01-colored/","title":"Colored","text":""},{"location":"02-library/03-utils-library/01-colored/#installation","title":"Installation","text":"<pre><code>cargo add colored\n</code></pre> <ul> <li>For more details, see the colored crate documentation.</li> </ul>"},{"location":"02-library/03-utils-library/01-colored/#usage","title":"Usage","text":"<pre><code>use colored::Colorize;\n\n\"this is blue\".blue();\n\"this is red\".red();\n\"this is red on blue\".red().on_blue();\n\"this is also red on blue\".on_blue().red();\n\"you can use truecolor values too!\".truecolor(0, 255, 136);\n\"background truecolor also works :)\".on_truecolor(135, 28, 167);\n\"you can also make bold comments\".bold();\nprintln!(\"{} {} {}\", \"or use\".cyan(), \"any\".italic().yellow(), \"string type\".cyan());\n\"or change advice. This is red\".yellow().blue().red();\n\"or clear things up. This is default color and style\".red().bold().clear();\n\"purple and magenta are the same\".purple().magenta();\n\"bright colors are also allowed\".bright_blue().on_bright_white();\n\"you can specify color by string\".color(\"blue\").on_color(\"red\");\n\"and so are normal and clear\".normal().clear();\nString::from(\"this also works!\").green().bold();\nformat!(\"{:30}\", \"format works as expected. This will be padded\".blue());\nformat!(\"{:.3}\", \"and this will be green but truncated to 3 chars\".green());\n</code></pre>"},{"location":"02-library/03-utils-library/01-colored/#sample","title":"Sample","text":"<pre><code>use colored::Colorize;\n\nfn main() {\n    let msgs = [\n        \"this is blue\".blue(),\n        \"this is red\".red(),\n        \"this is red on blue\".red().on_blue(),\n        \"this is also red on blue\".on_yellow().red(),\n        \"you can use truecolor values too!\".truecolor(0, 255, 136),\n        \"background truecolor also works :)\".on_truecolor(135, 28, 167),\n    ];\n\n    for msg in msgs {\n        println!(\"{}\", msg);\n    }\n}\n</code></pre>"},{"location":"02-library/03-utils-library/01-colored/#output","title":"Output","text":""},{"location":"02-library/03-utils-library/02-clap/","title":"Clap Notes","text":""},{"location":"02-library/03-utils-library/02-clap/#1-introduction-to-clap","title":"1. Introduction to Clap","text":"<p>Clap is a Rust library for parsing command-line arguments. It provides an easy-to-use API for defining arguments, options, flags, and subcommands.</p>"},{"location":"02-library/03-utils-library/02-clap/#2-adding-clap-to-your-project","title":"2. Adding Clap to Your Project","text":"<p>Add the following to <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nclap = { version = \"4\", features = [\"derive\"] }\n</code></pre> Why <code>features = [\"derive\"]</code> in <code>clap = { version = \"4\", features = [\"derive\"] }</code>? <p>By default, <code>clap</code> doesn\u2019t include support for the <code>#[derive(Parser)]</code> macro unless you explicitly enable the <code>\"derive\"</code> feature.</p>"},{"location":"02-library/03-utils-library/02-clap/#without-features-derive","title":"\ud83d\udd0d Without <code>features = [\"derive\"]</code>","text":"<p>You\u2019d have to build your CLI manually using the builder API:</p> <pre><code>use clap::{Arg, Command};\n\nlet matches = Command::new(\"myapp\")\n    .arg(Arg::new(\"verbose\").short('v').long(\"verbose\"))\n    .get_matches();\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#with-features-derive","title":"\u2705 With <code>features = [\"derive\"]</code>","text":"<p>You unlock the <code>#[derive(Parser)]</code> macro and everything it needs (like <code>Subcommand</code>, <code>Args</code>, etc.):</p> <pre><code>use clap::Parser;\n\n#[derive(Parser)]\nstruct Cli {\n    #[arg(short, long)]\n    verbose: bool,\n}\n</code></pre> <p>This declarative approach is cleaner, especially for complex CLIs.</p>"},{"location":"02-library/03-utils-library/02-clap/#tldr","title":"TL;DR","text":"<ul> <li><code>clap</code> is modular to reduce compile time and binary size.</li> <li>The <code>\"derive\"</code> feature enables procedural macros like <code>#[derive(Parser)]</code>.</li> <li>Always include it if you\u2019re using <code>derive</code>-style command line parsing.</li> </ul>"},{"location":"02-library/03-utils-library/02-clap/#3-basic-usage","title":"3. Basic Usage","text":"<pre><code>use clap::Parser;\n\n#[derive(Parser)]\nstruct Args {\n    #[arg(short, long)]\n    name: String,\n}\n\nfn main() {\n    let args = Args::parse();\n    println!(\"Hello, {}!\", args.name);\n}\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#running","title":"Running","text":"<pre><code>cargo run -- --name Alice\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#output","title":"Output","text":"<pre><code>Hello, Alice!\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#4-flags-and-options","title":"4. Flags and Options","text":"<pre><code>use clap::Parser;\n\n#[derive(Parser)]\nstruct Args {\n    #[arg(short, long)]\n    verbose: bool,\n}\n\nfn main() {\n    let args = Args::parse();\n    if args.verbose {\n        println!(\"Verbose mode enabled\");\n    }\n}\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#running_1","title":"Running","text":"<pre><code>cargo run -- --verbose\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#output_1","title":"Output","text":"<pre><code>Verbose mode enabled\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#5-default-values","title":"5. Default Values","text":"<pre><code>use clap::Parser;\n\n#[derive(Parser)]\nstruct Args {\n    #[arg(short, long, default_value_t = 10)]\n    count: u32,\n}\n\nfn main() {\n    let args = Args::parse();\n    println!(\"Count: {}\", args.count);\n}\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#6-subcommands","title":"6. Subcommands","text":"<pre><code>use clap::{Parser, Subcommand};\n\n#[derive(Parser)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    Add { value: i32 },\n    Remove { value: i32 },\n}\n\nfn main() {\n    let cli = Cli::parse();\n    match cli.command {\n        Commands::Add { value } =&gt; println!(\"Adding: {}\", value),\n        Commands::Remove { value } =&gt; println!(\"Removing: {}\", value),\n    }\n}\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#running_2","title":"Running","text":"<pre><code>cargo run -- add 42\ncargo run -- remove 42\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#7-validating-input","title":"7. Validating Input","text":"<pre><code>use clap::Parser;\n\n#[derive(Parser)]\nstruct Args {\n    #[arg(short, long, value_parser = clap::value_parser!(u32).range(1..=100))]\n    percentage: u32,\n}\n\nfn main() {\n    let args = Args::parse();\n    println!(\"Percentage: {}\", args.percentage);\n}\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#8-help-and-version-auto-generation","title":"8. Help and Version Auto-Generation","text":"<p>Clap automatically generates help and version messages.</p> <pre><code>use clap::Parser;\n\n#[derive(Parser)]\n#[command(version = \"1.0\", about = \"Example CLI tool\")]\nstruct Args {}\n\nfn main() {\n    let _args = Args::parse();\n}\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#running_3","title":"Running","text":"<pre><code>cargo run -- --help\ncargo run -- --version\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#9-nested-subcommands","title":"9. <code>Nested Subcommands</code>","text":"<p>You can nest subcommands inside other subcommands using enums.</p>"},{"location":"02-library/03-utils-library/02-clap/#example-user-update-bio-user-update-dp","title":"\u2705 Example: <code>user update bio</code>, <code>user update dp</code>","text":"<pre><code>use clap::{Parser, Subcommand};\n\n#[derive(Parser)]\n#[command(name = \"app\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    User(UserCommand),\n    // Other top-level commands\n}\n\n#[derive(Subcommand)]\nenum UserCommand {\n    Update(UpdateCommand),\n    Show,\n}\n\n#[derive(Subcommand)]\nenum UpdateCommand {\n    Bio {\n        #[arg()]\n        text: String,\n    },\n    Dp {\n        #[arg()]\n        path: String,\n    },\n}\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#example-cli-usage","title":"\ud83e\uddea Example CLI Usage","text":"<pre><code>app user update bio \"cool engineer at tau\"\napp user update dp ~/me.png\napp user show\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#pattern-matching","title":"\ud83e\udde0 Pattern Matching","text":"<pre><code>fn main() {\n    let cli = Cli::parse();\n\n    match &amp;cli.command {\n        Commands::User(user_cmd) =&gt; match user_cmd {\n            UserCommand::Update(update_cmd) =&gt; match update_cmd {\n                UpdateCommand::Bio { text } =&gt; println!(\"Updating bio: {}\", text),\n                UpdateCommand::Dp { path } =&gt; println!(\"Updating dp: {}\", path),\n            },\n            UserCommand::Show =&gt; println!(\"Showing user info\"),\n        },\n    }\n}\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#notes","title":"\ud83d\udcdd Notes","text":"<ul> <li>Each <code>Subcommand</code> enum can contain other enums marked with <code>#[derive(Subcommand)]</code>.</li> <li>You can go arbitrarily deep (though practically 2\u20133 levels is ideal).</li> <li>It\u2019s good practice to keep logic modular with one module per command group if you grow large.</li> </ul> <p>Absolutely. Let's enrich your <code>clap</code> notes with how to add descriptions, long help, per-argument docs, and fine control over help output \u2014 all in your usual markdown style.</p>"},{"location":"02-library/03-utils-library/02-clap/#10-adding-description-docs-and-help-text-in-clap","title":"10. Adding Description, Docs, and Help Text in <code>clap</code>","text":""},{"location":"02-library/03-utils-library/02-clap/#at-the-cli-level-app-wide-metadata","title":"\ud83d\udce6 At the CLI level (App-wide metadata)","text":"<pre><code>use clap::Parser;\n\n#[derive(Parser)]\n#[command(\n    name = \"litracer\",\n    version = \"0.1.0\",\n    author = \"Deependu Jha\",\n    about = \"Trace log visualizer for Lightning AI\",\n    long_about = \"Converts structured logs into Chrome Trace format to analyze bottlenecks in distributed training.\"\n)]\nstruct Cli {\n    // ...\n}\n</code></pre> <ul> <li><code>about</code> \u2192 short help shown in <code>--help</code></li> <li><code>long_about</code> \u2192 detailed explanation (multi-line allowed)</li> </ul>"},{"location":"02-library/03-utils-library/02-clap/#at-the-argument-level","title":"\ud83d\udd20 At the argument level","text":"<pre><code>#[derive(Parser)]\nstruct Cli {\n    /// Show more debugging output (shorthand: -v)\n    #[arg(short, long, help = \"Increase output verbosity\")]\n    verbose: bool,\n\n    /// Optional input file to parse\n    #[arg(short, long, help = \"Specify a log file to trace\", long_help = \"Provide the path to the structured log file generated by Lightning AI components.\")]\n    input: Option&lt;String&gt;,\n}\n</code></pre> <ul> <li><code>///</code> doc comments are parsed by default into help text</li> <li><code>help = \"...\"</code> gives a custom help message</li> <li><code>long_help = \"...\"</code> gives an extended message for <code>--help</code></li> </ul>"},{"location":"02-library/03-utils-library/02-clap/#for-subcommands","title":"\ud83e\udde9 For Subcommands","text":"<pre><code>#[derive(Subcommand)]\nenum Commands {\n    /// Parse and visualize a trace file\n    Parse {\n        #[arg(short, long, help = \"Path to trace JSON\")]\n        file: String,\n    },\n\n    /// Compare two trace files\n    Compare {\n        #[arg(help = \"Baseline trace\")]\n        base: String,\n\n        #[arg(help = \"Target trace\")]\n        target: String,\n    },\n}\n</code></pre> <p>Each subcommand and argument can have:</p> <ul> <li><code>///</code> doc string (preferred for short messages)</li> <li><code>.help =</code> or <code>.long_help =</code> (for richer formatting)</li> </ul>"},{"location":"02-library/03-utils-library/02-clap/#pro-tips","title":"\u270d\ufe0f Pro Tips","text":"<ul> <li>Use <code>\\n\\n</code> in <code>long_help</code> for paragraph breaks.</li> <li>Use Markdown in <code>long_about</code> if you display help in a custom UI.</li> <li>Keep short <code>help</code> concise for single-line display.</li> </ul>"},{"location":"02-library/03-utils-library/02-clap/#11-args-in-clap","title":"11. <code>Args</code> in <code>clap</code>","text":"<p>The <code>Args</code> derive macro in <code>clap</code> is the third sibling to <code>Parser</code> and <code>Subcommand</code>, and it's used to modularize and reuse argument definitions across multiple commands.</p>"},{"location":"02-library/03-utils-library/02-clap/#deriveargs-when-and-why","title":"\ud83e\udde9 <code>#[derive(Args)]</code> \u2014 When and Why?","text":"<p>You use <code>Args</code> when you want to:</p> <ul> <li>Define a reusable chunk of arguments.</li> <li>Compose those args into multiple <code>Parser</code> or <code>Subcommand</code> structs.</li> <li>Keep your CLI definition modular and clean.</li> </ul> <p>Think of it like a building block for your CLI's options and flags.</p>"},{"location":"02-library/03-utils-library/02-clap/#example-shared-flags-between-subcommands","title":"\u2705 Example: Shared Flags Between Subcommands","text":"<pre><code>use clap::{Parser, Subcommand, Args};\n\n#[derive(Parser)]\n#[command(name = \"litcli\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Download a trace\n    Download(DownloadArgs),\n\n    /// Upload a trace\n    Upload(UploadArgs),\n}\n\n/// Shared options for download/upload\n#[derive(Args)]\nstruct CommonArgs {\n    /// Enable verbose logging\n    #[arg(short, long)]\n    verbose: bool,\n\n    /// Set the remote bucket\n    #[arg(long)]\n    bucket: String,\n}\n\n#[derive(Args)]\nstruct DownloadArgs {\n    #[command(flatten)]\n    common: CommonArgs,\n\n    /// Name of the file to download\n    #[arg(long)]\n    file: String,\n}\n\n#[derive(Args)]\nstruct UploadArgs {\n    #[command(flatten)]\n    common: CommonArgs,\n\n    /// Path to the file to upload\n    #[arg(long)]\n    path: String,\n}\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#whats-happening","title":"\ud83e\uddc3 What's happening?","text":"<ul> <li><code>#[derive(Args)]</code>: Declares that this struct contains CLI arguments (but is not a full parser or subcommand).</li> <li><code>#[command(flatten)]</code>: Merges the fields of the <code>CommonArgs</code> struct into the outer one. Useful for composition.</li> <li>Each command reuses the same chunk of flags (<code>--verbose</code>, <code>--bucket</code>) without redefining them.</li> </ul>"},{"location":"02-library/03-utils-library/02-clap/#tldr-cheatsheet","title":"\ud83e\udde0 TL;DR Cheatsheet","text":"Macro Purpose <code>Parser</code> Top-level CLI parser <code>Subcommand</code> Enum to define CLI subcommands <code>Args</code> Reusable set of arguments or flags"},{"location":"02-library/03-utils-library/02-clap/#12-clap-completion","title":"12. Clap Completion","text":""},{"location":"02-library/03-utils-library/02-clap/#clap_complete-shell-completion-for-cli-tools","title":"<code>clap_complete</code>: Shell Completion for CLI Tools","text":"<p><code>clap_complete</code> is a companion crate to <code>clap</code> that enables shell completion generation (e.g. for <code>bash</code>, <code>zsh</code>, <code>fish</code>, <code>powershell</code>, <code>elvish</code>, etc.).</p> <ul> <li>You can also check this code for understanding: clap_complete example</li> </ul>"},{"location":"02-library/03-utils-library/02-clap/#add-dependency","title":"\ud83d\udce6 Add Dependency","text":"<pre><code># Cargo.toml\n[dependencies]\nclap = { version = \"4.5\", features = [\"derive\"] }\n\n[build-dependencies]\nclap_complete = \"4.5\"\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#basic-usage-in-mainrs","title":"\u2699\ufe0f Basic Usage in <code>main.rs</code>","text":"<pre><code>use clap::{Command, CommandFactory, Parser};\nuse clap_complete::aot::{Generator, Zsh, generate};\nuse std::io;\n\n#[derive(Parser)]\nstruct Args {\n    #[arg(short, long)]\n    name: String,\n}\n\nfn print_completions&lt;G: Generator&gt;(generator: G, cmd: &amp;mut Command) {\n    generate(\n        generator,\n        cmd,\n        cmd.get_name().to_string(),\n        &amp;mut io::stdout(),\n    );\n}\n\nfn main() {\n    let args = Args::parse();\n    println!(\"Hello, {}!\", args.name);\n\n    print_completions(Zsh, &amp;mut Args::command());\n}\n</code></pre>"},{"location":"02-library/03-utils-library/02-clap/#optional-write-to-file-in-build-script-buildrs","title":"\ud83d\udcc1 Optional: Write to File in Build Script (<code>build.rs</code>)","text":"<p>If you want to auto-generate completions on <code>cargo build</code>, use this:</p> <pre><code>use clap_complete::{generate_to, shells::Zsh};\nuse std::env;\nuse std::path::Path;\n\ninclude!(\"src/cli.rs\"); // wherever your build_cli() lives\n\nfn main() {\n    let outdir = env::var_os(\"OUT_DIR\").unwrap();\n    generate_to(\n        Zsh,\n        &amp;mut Args::command(),\n        \"myapp\",\n        Path::new(&amp;outdir),\n    ).unwrap();\n}\n</code></pre> <p>\ud83d\udcdd Add generated path to install script or package instructions.</p>"},{"location":"02-library/03-utils-library/02-clap/#notes_1","title":"\ud83d\udca1 Notes","text":"<ul> <li>You can use other shells too: <code>Bash</code>, <code>Zsh</code>, <code>Fish</code>, <code>PowerShell</code>, <code>Elvish</code>.</li> <li>The third argument in <code>generate</code> / <code>generate_to</code> must match the CLI binary name.</li> <li>If using subcommands, completions auto-include them!</li> </ul>"},{"location":"02-library/03-utils-library/03-serde/","title":"Serde &amp; Serde JSON Notes","text":""},{"location":"02-library/03-utils-library/03-serde/#1-introduction-to-serde","title":"1. Introduction to Serde","text":"<p>Serde is a framework for serializing and deserializing Rust data structures efficiently.</p>"},{"location":"02-library/03-utils-library/03-serde/#adding-serde-to-your-project","title":"Adding Serde to Your Project","text":"<pre><code>[dependencies]\nserde = { version = \"1\", features = [\"derive\"] }\nserde_json = \"1\"\n</code></pre>"},{"location":"02-library/03-utils-library/03-serde/#2-basic-serialization-deserialization","title":"2. Basic Serialization &amp; Deserialization","text":"<pre><code>use serde::{Serialize, Deserialize};\nuse serde_json;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Person {\n    name: String,\n    age: u8,\n}\n\nfn main() {\n    let person = Person { name: \"Alice\".to_string(), age: 25 };\n\n    // Serialization (Struct -&gt; JSON)\n    let json_str = serde_json::to_string(&amp;person).unwrap();\n    println!(\"Serialized: {json_str}\");\n\n    // Deserialization (JSON -&gt; Struct)\n    let deserialized: Person = serde_json::from_str(&amp;json_str).unwrap();\n    println!(\"Deserialized: {:?}\", deserialized);\n}\n</code></pre>"},{"location":"02-library/03-utils-library/03-serde/#3-using-serde_jsonvalue","title":"3. Using <code>serde_json::Value</code>","text":"<p>For working with arbitrary JSON structures:</p> <pre><code>use serde_json::Value;\n\nfn main() {\n    let data = r#\"{ \"name\": \"Bob\", \"age\": 30 }\"#;\n    let v: Value = serde_json::from_str(data).unwrap();\n    println!(\"Name: {}\", v[\"name\"]);\n    println!(\"Age: {}\", v[\"age\"]);\n}\n</code></pre> <p>Note</p> <ul> <li>The pound symbol <code>(#)</code> in <code>r#\"{ \"name\": \"Bob\", \"age\": 30 }\"#</code> is used in Rust to create a raw string literal.</li> <li>The <code>#\"</code> and <code>\"#</code> essentially tell Rust, <code>This entire section in the middle is my string, and I don't want you to interpret any special characters within it. Just take it literally.</code></li> </ul>"},{"location":"02-library/03-utils-library/03-serde/#4-handling-optionals-defaults","title":"4. Handling Optionals &amp; Defaults","text":"<pre><code>use serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Config {\n    #[serde(default = \"default_host\")]\n    host: String,\n    port: Option&lt;u16&gt;,\n}\n\nfn default_host() -&gt; String {\n    \"localhost\".to_string()\n}\n</code></pre>"},{"location":"02-library/03-utils-library/03-serde/#5-ignoring-fields","title":"5. Ignoring Fields","text":"<pre><code>#[derive(Serialize, Deserialize)]\nstruct User {\n    id: u32,\n    #[serde(skip_serializing)]\n    password: String,\n}\n</code></pre>"},{"location":"02-library/03-utils-library/03-serde/#6-renaming-fields","title":"6. Renaming Fields","text":"<pre><code>#[derive(Serialize, Deserialize)]\nstruct Server {\n    #[serde(rename = \"ipAddress\")]\n    ip: String,\n}\n</code></pre>"},{"location":"02-library/03-utils-library/03-serde/#7-serializing-to-pretty-json","title":"7. Serializing to Pretty JSON","text":"<pre><code>let pretty_json = serde_json::to_string_pretty(&amp;person).unwrap();\nprintln!(\"{pretty_json}\");\n</code></pre>"},{"location":"02-library/03-utils-library/04-indicatif/","title":"\ud83d\udccc Rust <code>indicatif</code> Cheat Sheet","text":"<p>The <code>indicatif</code> crate provides progress bars, spinners, and multi-bar support for terminal applications.</p>"},{"location":"02-library/03-utils-library/04-indicatif/#install-indicatif","title":"\ud83d\udce6 Install <code>indicatif</code>","text":"<pre><code>cargo add indicatif\n</code></pre>"},{"location":"02-library/03-utils-library/04-indicatif/#1-basic-progress-bar","title":"1\ufe0f\u20e3 Basic Progress Bar","text":"<pre><code>use indicatif::ProgressBar;\nuse std::thread::sleep;\nuse std::time::Duration;\n\nfn main() {\n    let bar = ProgressBar::new(100); // Create a progress bar with 100 steps\n\n    for _ in 0..100 {\n        bar.inc(1); // Increment progress by 1\n        sleep(Duration::from_millis(50));\n    }\n\n    bar.finish(); // Mark as completed\n}\n</code></pre> Method Description <code>ProgressBar::new(n)</code> Creates a new progress bar with <code>n</code> steps <code>.inc(n)</code> Increments progress by <code>n</code> <code>.finish()</code> Marks the bar as completed"},{"location":"02-library/03-utils-library/04-indicatif/#2-customizing-progress-bar-style","title":"2\ufe0f\u20e3 Customizing Progress Bar Style","text":"<pre><code>use indicatif::{ProgressBar, ProgressStyle};\nuse std::thread::sleep;\nuse std::time::Duration;\n\nfn main() {\n    let bar = ProgressBar::new(50);\n    bar.set_style(\n        ProgressStyle::default_bar()\n            .template(\"{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos:&gt;3}/{len} ({eta})\")\n            .unwrap()\n            .progress_chars(\"#&gt;-\"),\n    );\n\n    for _ in 0..50 {\n        bar.inc(1);\n        sleep(Duration::from_millis(100));\n    }\n\n    bar.finish_with_message(\"\u2705 Done!\");\n}\n</code></pre> Method Description <code>.set_style(style)</code> Sets a custom style for the progress bar <code>.template(\"{...}\")</code> Defines the bar format <code>.progress_chars(\"#&gt;-\")</code> Sets progress characters <code>.finish_with_message(\"text\")</code> Marks as finished with a message"},{"location":"02-library/03-utils-library/04-indicatif/#3-using-a-spinner","title":"3\ufe0f\u20e3 Using a Spinner","text":"<pre><code>use indicatif::{ProgressBar, ProgressStyle};\nuse std::thread::sleep;\nuse std::time::Duration;\n\nfn main() {\n    let spinner = ProgressBar::new_spinner();\n    spinner.set_style(ProgressStyle::default_spinner().template(\"{spinner:.green} {msg}\").unwrap());\n\n    spinner.set_message(\"Loading...\");\n\n    for _ in 0..10 {\n        spinner.tick(); // Update spinner animation\n        sleep(Duration::from_millis(300));\n    }\n\n    spinner.finish_with_message(\"\u2705 Completed!\");\n}\n</code></pre> Method Description <code>ProgressBar::new_spinner()</code> Creates a spinner <code>.tick()</code> Updates the spinner animation <code>.set_message(\"text\")</code> Sets the spinner message"},{"location":"02-library/03-utils-library/04-indicatif/#4-multi-progress-multiple-progress-bars","title":"4\ufe0f\u20e3 Multi-Progress (Multiple Progress Bars)","text":"<pre><code>use indicatif::{MultiProgress, ProgressBar};\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let m = MultiProgress::new();\n    let bar1 = m.add(ProgressBar::new(50));\n    let bar2 = m.add(ProgressBar::new(50));\n\n    let handle1 = thread::spawn(move || {\n        for _ in 0..50 {\n            bar1.inc(1);\n            thread::sleep(Duration::from_millis(50));\n        }\n        bar1.finish_with_message(\"\u2705 Task 1 Complete\");\n    });\n\n    let handle2 = thread::spawn(move || {\n        for _ in 0..50 {\n            bar2.inc(1);\n            thread::sleep(Duration::from_millis(70));\n        }\n        bar2.finish_with_message(\"\u2705 Task 2 Complete\");\n    });\n\n    handle1.join().unwrap();\n    handle2.join().unwrap();\n}\n</code></pre> Method Description <code>MultiProgress::new()</code> Creates a multi-progress handler <code>.add(ProgressBar::new(n))</code> Adds a new progress bar to multi-bar"},{"location":"02-library/03-utils-library/04-indicatif/#5-download-progress-with-bytes-format","title":"5\ufe0f\u20e3 Download Progress with Bytes Format","text":"<pre><code>use indicatif::{ProgressBar, ProgressStyle};\nuse std::thread::sleep;\nuse std::time::Duration;\n\nfn main() {\n    let bar = ProgressBar::new(1024 * 1024 * 500); // 500 MB download\n    bar.set_style(ProgressStyle::default_bar().template(\"{bar:40.cyan} {bytes}/{total_bytes} ({eta})\").unwrap());\n\n    for _ in 0..500 {\n        bar.inc(1024 * 1024); // Simulating 1MB download per tick\n        sleep(Duration::from_millis(100));\n    }\n\n    bar.finish_with_message(\"\u2705 Download Complete\");\n}\n</code></pre> Method Description <code>{bytes}</code> Displays progress in bytes <code>{total_bytes}</code> Shows total bytes <code>{eta}</code> Shows estimated time remaining"},{"location":"02-library/03-utils-library/04-indicatif/#6-steady-progress-bars-auto-increment","title":"6\ufe0f\u20e3 Steady Progress Bars (Auto-Increment)","text":"<p>why will I use it?</p> <ul> <li>You want a spinner or status indicator to keep moving even if no manual updates are made.</li> <li>You're waiting for an event or long-running operation with unknown duration.</li> <li>You need a \"heartbeat\" effect to indicate that a program is still alive.</li> <li>Example Use Case: \ud83d\udd39 Display a loading spinner while waiting for a network request.</li> </ul> <pre><code>use indicatif::{ProgressBar, ProgressStyle};\nuse std::thread::sleep;\nuse std::time::Duration;\n\nfn main() {\n    let spinner = ProgressBar::new_spinner();\n    spinner.set_style(ProgressStyle::default_spinner().template(\"{spinner:.green} Waiting...\").unwrap());\n\n    spinner.enable_steady_tick(Duration::from_millis(100)); // Updates automatically every 100ms\n\n    sleep(Duration::from_secs(5)); // Simulating a network request\n\n    spinner.finish_with_message(\"\u2705 Request completed!\");\n}\n</code></pre> Method Description <code>.enable_steady_tick(duration)</code> Automatically updates progress"},{"location":"02-library/03-utils-library/04-indicatif/#7-creating-hidden-progress-bars","title":"7\ufe0f\u20e3 Creating Hidden Progress Bars","text":"<pre><code>use indicatif::ProgressBar;\n\nfn main() {\n    let bar = ProgressBar::hidden(); // Invisible bar\n    bar.inc(1);\n}\n</code></pre> Method Description <code>ProgressBar::hidden()</code> Creates an invisible progress bar"},{"location":"02-library/03-utils-library/04-indicatif/#8-using-progress-bar-with-iterators","title":"8\ufe0f\u20e3 Using Progress Bar with Iterators","text":"<pre><code>use indicatif::ProgressIterator;\nuse std::thread::sleep;\nuse std::time::Duration;\n\nfn main() {\n    for _ in (0..100).progress() {\n        sleep(Duration::from_millis(50));\n    }\n}\n</code></pre> Method Description <code>.progress()</code> Adds a progress bar to an iterator"},{"location":"02-library/03-utils-library/04-indicatif/#summary","title":"\ud83d\udccc Summary","text":"Feature Method Basic Progress Bar <code>ProgressBar::new(n)</code>, <code>.inc(n)</code>, <code>.finish()</code> Custom Styles <code>.set_style(style)</code>, <code>.template(\"{bar}\")</code> Spinner <code>ProgressBar::new_spinner()</code>, <code>.tick()</code> Multi-Progress <code>MultiProgress::new()</code>, <code>.add(bar)</code> Bytes Download <code>{bytes}/{total_bytes}</code>, <code>{eta}</code> Steady Tick <code>.enable_steady_tick(duration)</code> Hidden Bar <code>ProgressBar::hidden()</code> Iterator Integration <code>.progress()</code>"},{"location":"02-library/03-utils-library/05-reqwest/","title":"\ud83d\udccc Rust <code>reqwest</code> Cheat Sheet","text":"<p><code>reqwest</code> is a popular HTTP client for Rust, built on top of <code>hyper</code>. It supports async and blocking requests.</p>"},{"location":"02-library/03-utils-library/05-reqwest/#add-reqwest-to-cargotoml","title":"\ud83d\udce6 Add <code>reqwest</code> to <code>Cargo.toml</code>","text":"<pre><code>[dependencies]\nreqwest = { version = \"0.11\", features = [\"json\", \"blocking\", \"stream\"] }\ntokio = { version = \"1\", features = [\"full\"] } # Needed for async\nserde = { version = \"1\", features = [\"derive\"] } # Needed for JSON serialization\nserde_json = \"1.0.138\"\n</code></pre>"},{"location":"02-library/03-utils-library/05-reqwest/#1-making-a-basic-get-request","title":"1\ufe0f\u20e3 Making a Basic GET Request","text":"<pre><code>use reqwest;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), reqwest::Error&gt; {\n    let response = reqwest::get(\"https://jsonplaceholder.typicode.com/posts/1\")\n        .await?\n        .text()\n        .await?;\n\n    println!(\"Response: {}\", response);\n    Ok(())\n}\n</code></pre> Method Description <code>.get(url).await?</code> Makes a GET request <code>.text().await?</code> Gets the response body as a String <code>.json::&lt;T&gt;().await?</code> Parses JSON into a struct"},{"location":"02-library/03-utils-library/05-reqwest/#2-using-a-client-for-multiple-requests","title":"2\ufe0f\u20e3 Using a <code>Client</code> for Multiple Requests","text":"<pre><code>use reqwest::Client;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), reqwest::Error&gt; {\n    let client = Client::new(); // Create once, reuse\n\n    let res1 = client.get(\"https://jsonplaceholder.typicode.com/posts/1\")\n        .send()\n        .await?\n        .text()\n        .await?;\n\n    let res2 = client.get(\"https://jsonplaceholder.typicode.com/posts/2\")\n        .send()\n        .await?\n        .text()\n        .await?;\n\n    println!(\"Response 1: {}\", res1);\n    println!(\"Response 2: {}\", res2);\n\n    Ok(())\n}\n</code></pre> <p>Why use a <code>Client</code>? \u2714\ufe0f Efficient: Avoids re-establishing connections \u2714\ufe0f Reuses TCP connections \u2714\ufe0f Allows setting default headers, timeout, etc.</p>"},{"location":"02-library/03-utils-library/05-reqwest/#3-sending-a-post-request-with-json","title":"3\ufe0f\u20e3 Sending a POST Request with JSON","text":"<pre><code>use reqwest::Client;\nuse serde_json::json;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), reqwest::Error&gt; {\n    let client = Client::new();\n\n    let response = client.post(\"https://jsonplaceholder.typicode.com/posts\")\n        .json(&amp;json!({\n            \"title\": \"Hello\",\n            \"body\": \"This is a test post\",\n            \"userId\": 1\n        }))\n        .send()\n        .await?\n        .text()\n        .await?;\n\n    println!(\"Response: {}\", response);\n    Ok(())\n}\n</code></pre> Method Description <code>.post(url)</code> Creates a POST request <code>.json(&amp;data)</code> Sends JSON data (requires <code>serde_json</code>)"},{"location":"02-library/03-utils-library/05-reqwest/#4-put-request-updating-data","title":"4\ufe0f\u20e3 PUT Request (Updating Data)","text":"<pre><code>use reqwest::Client;\nuse serde_json::json;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), reqwest::Error&gt; {\n    let client = Client::new();\n\n    let response = client.put(\"https://jsonplaceholder.typicode.com/posts/1\")\n        .json(&amp;json!({\n            \"id\": 1,\n            \"title\": \"Updated Title\",\n            \"body\": \"Updated body content\",\n            \"userId\": 1\n        }))\n        .send()\n        .await?\n        .text()\n        .await?;\n\n    println!(\"Response: {}\", response);\n    Ok(())\n}\n</code></pre> Method Description <code>.put(url)</code> Makes a PUT request (update resource)"},{"location":"02-library/03-utils-library/05-reqwest/#5-delete-request","title":"5\ufe0f\u20e3 DELETE Request","text":"<pre><code>use reqwest::Client;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), reqwest::Error&gt; {\n    let client = Client::new();\n\n    let response = client.delete(\"https://jsonplaceholder.typicode.com/posts/1\")\n        .json(&amp;json!({\n            \"userId\": 1\n        }))\n        .send()\n        .await?\n        .text()\n        .await?;\n\n    println!(\"Deleted Response: {}\", response);\n    Ok(())\n}\n</code></pre> Method Description <code>.delete(url)</code> Deletes a resource"},{"location":"02-library/03-utils-library/05-reqwest/#6-setting-headers","title":"6\ufe0f\u20e3 Setting Headers","text":"<pre><code>use reqwest::{Client, header};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), reqwest::Error&gt; {\n    let client = Client::new();\n\n    let response = client.get(\"https://jsonplaceholder.typicode.com/posts/1\")\n        .header(header::USER_AGENT, \"MyRustApp/1.0\")\n        .header(header::RANGE, \"bytes=0-499\")\n        .send()\n        .await?\n        .text()\n        .await?;\n\n    println!(\"Response: {}\", response);\n    Ok(())\n}\n</code></pre> Method Description <code>.header(header::NAME, \"Value\")</code> Adds custom headers"},{"location":"02-library/03-utils-library/05-reqwest/#7-streaming-large-downloads","title":"7\ufe0f\u20e3 Streaming Large Downloads","text":"<pre><code>use reqwest::Client;\nuse tokio::io::AsyncWriteExt; // For writing to file\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), reqwest::Error&gt; {\n    let client = Client::new();\n\n    let mut response = client\n        .get(\"https://avatars.githubusercontent.com/u/76887609\")\n        .send()\n        .await?;\n\n    let mut file = tokio::fs::File::create(\"downloaded_file.jpg\").await.unwrap();\n\n    while let Some(chunk) = response.chunk().await? {\n        file.write_all(&amp;chunk).await.unwrap();\n    }\n\n    println!(\"Download complete!\");\n    Ok(())\n}\n</code></pre> Method Description <code>.bytes_stream()</code> Streams the response body <code>.write_all(&amp;chunk?)</code> Writes each chunk to a file"},{"location":"02-library/03-utils-library/05-reqwest/#8-handling-timeouts","title":"8\ufe0f\u20e3 Handling Timeouts","text":"<pre><code>use reqwest::Client;\nuse std::time::Duration;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), reqwest::Error&gt; {\n    let client = Client::builder()\n        .timeout(Duration::from_secs(5)) // Set timeout\n        .build()?;\n\n    let response = client.get(\"https://jsonplaceholder.typicode.com/posts/1\")\n        .send()\n        .await?\n        .text()\n        .await?;\n\n    println!(\"Response: {}\", response);\n    Ok(())\n}\n</code></pre> Method Description <code>.timeout(Duration::from_secs(n))</code> Sets a request timeout"},{"location":"02-library/03-utils-library/05-reqwest/#9-handling-errors-gracefully","title":"9\ufe0f\u20e3 Handling Errors Gracefully","text":"<pre><code>use reqwest::Client;\n\n#[tokio::main]\nasync fn main() {\n    let client = Client::new();\n\n    match client.get(\"https://invalid-url.typicode.com\")\n        .send()\n        .await\n    {\n        Ok(response) =&gt; println!(\"Response: {:?}\", response),\n        Err(err) =&gt; println!(\"Error: {}\", err),\n    }\n}\n</code></pre> Method Description <code>.send().await?</code> Returns a <code>Result&lt;Response, reqwest::Error&gt;</code>"},{"location":"02-library/03-utils-library/05-reqwest/#blocking-requests-sync","title":"\ud83d\udd1f Blocking Requests (Sync)","text":"<p>For synchronous (blocking) requests, use:</p> <pre><code>use reqwest::blocking::get;\n\nfn main() -&gt; Result&lt;(), reqwest::Error&gt; {\n    let response = get(\"https://jsonplaceholder.typicode.com/posts/1\")?\n        .text()?;\n\n    println!(\"Response: {}\", response);\n    Ok(())\n}\n</code></pre> Feature Description <code>\"blocking\"</code> Enables synchronous requests <code>reqwest::blocking::get()</code> Sync version of <code>reqwest::get()</code>"},{"location":"02-library/03-utils-library/05-reqwest/#summary","title":"\ud83d\udccc Summary","text":"Category Method Basic Requests <code>.get()</code>, <code>.post()</code>, <code>.put()</code>, <code>.delete()</code> Sending Data <code>.json(&amp;data)</code>, <code>.header()</code> Streaming Data <code>.bytes_stream()</code>, <code>.write_all()</code> Handling Errors <code>match response.send()</code> Blocking Mode <code>reqwest::blocking::get()</code> Timeouts <code>.timeout(Duration::from_secs(n))</code>"},{"location":"03-concurrency/01-multithreading/01-multithreading/","title":"Multithreading in Rust","text":""},{"location":"04-advanced/01-build-and-ffi/00-workspace/","title":"Rust Cargo Workspaces","text":"<p>A workspace is a group of crates managed together under one top-level Cargo.toml. It allows shared dependency resolution, unified builds/tests, and centralized configuration.</p>"},{"location":"04-advanced/01-build-and-ffi/00-workspace/#declaration","title":"Declaration","text":"<p>Top-level <code>Cargo.toml</code>:</p> <pre><code>[workspace]\nresolver = \"2\"         # use new feature resolver (optional)\nmembers = [\"crate_a\", \"crate_b\", \"examples/*\"]\nexclude = [\"old_crate\"]\n\n[workspace.dependencies]   # optional\nserde = \"1\"                # shared dependency for all members\n</code></pre> <ul> <li><code>resolver</code> \u2192 \"1\" (default) or \"2\" (new, more flexible, better for dependency resolution).</li> <li><code>members</code> \u2192 list of crate paths included in the workspace. Can use globs (<code>examples/*</code>).</li> <li><code>exclude</code> \u2192 paths to ignore (e.g., archived crates).</li> <li><code>[workspace.dependencies]</code> \u2192 dependencies shared by all members.<ul> <li>Members can override locally or use <code>workspace = true</code> to inherit.</li> </ul> </li> </ul>"},{"location":"04-advanced/01-build-and-ffi/00-workspace/#member-crates","title":"Member Crates","text":"<p><code>crate_a/Cargo.toml</code> example:</p> <pre><code>[package]\nname = \"crate_a\"\nversion = \"0.1.0\"\n\n[dependencies]\nserde = { workspace = true }   # pulls version from workspace\ntokio = { version = \"1\", optional = true }  # local override\ncrate_b = { path = \"../crate_b\" }           # inter-crate dependency\n</code></pre> <p>Notes:</p> <ul> <li><code>workspace = true</code> \u2192 ensures all crates use the same version from <code>[workspace.dependencies]</code>.</li> <li>Inter-crate path dependencies are local and versioned independently from crates.io.</li> <li>Optional features can still be enabled per member.</li> </ul>"},{"location":"04-advanced/01-build-and-ffi/00-workspace/#common-workspace-features-gotchas","title":"Common Workspace Features &amp; Gotchas","text":"<p>Profiles (<code>[profile.dev]</code>, <code>[profile.release]</code>)</p> <pre><code>* Can be defined globally under `[workspace]`.\n* Member crates inherit unless overridden.\n</code></pre> <p>Shared Lints / Metadata</p> <pre><code>[workspace.metadata]\nclippy = { deny_warnings = true }\n</code></pre> <p>Publishing</p> <ul> <li>Each member crate is published separately unless marked <code>publish = false</code>.</li> <li>Workspace crate cannot be published itself; only members.</li> </ul> <p>Examples / Tests / Benches</p> <ul> <li>Members can have their own <code>examples/</code>, <code>tests/</code>, <code>benches/</code>.</li> <li>Workspace allows <code>cargo test --all</code> or <code>cargo build --all</code>.</li> </ul> <p>Dev-dependencies in Workspace</p> <ul> <li>Dev-dependencies are not shared by default.</li> <li><code>[workspace.dev-dependencies]</code> can be declared to avoid repeating them in each member.</li> </ul> <p>Features Across Workspace</p> <ul> <li>Each crate manages its own features.</li> <li>Can \u201cforward\u201d dependency features using <code>dep:crate</code> or <code>crate/feature</code>.</li> <li><code>cargo build --all-features</code> \u2192 enables all features in all workspace members.</li> </ul> <p>Overriding Dependencies</p> <pre><code>[patch.crates-io]\nserde = { git = \"https://github.com/serde-rs/serde\", branch = \"master\" }\n</code></pre> <ul> <li>Overrides a crate globally for all workspace members.</li> </ul>"},{"location":"04-advanced/01-build-and-ffi/00-workspace/#commands","title":"Commands","text":"<ul> <li><code>cargo build</code> \u2192 builds current crate</li> <li><code>cargo build -p crate_a</code> \u2192 builds specific member</li> <li><code>cargo build --all</code> \u2192 builds all workspace members</li> <li><code>cargo test --all</code> \u2192 runs all tests across workspace</li> <li><code>cargo check --workspace</code> \u2192 checks all members without building</li> <li><code>cargo update -p crate_name</code> \u2192 update a dependency for all members</li> </ul>"},{"location":"04-advanced/01-build-and-ffi/00-workspace/#real-world-notes","title":"Real-world Notes","text":"<ul> <li>Large OSS projects use workspaces to avoid multiple lockfiles and keep dependencies consistent.</li> <li>Optional features and dev-dependencies often vary per crate; shared dependencies minimize version conflicts.</li> <li>Beware of cyclic dependencies \u2014 Cargo forbids them even inside a workspace.</li> <li>Path dependencies are local and always take precedence over crates.io.</li> </ul>"},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/","title":"Conditional Compilation &amp; Attributes (<code>cfg</code> &amp; <code>cfg_attr</code>)","text":"<p>Rust\u2019s <code>cfg</code> system allows conditional compilation based on platform, features, or custom flags. It works at compile time, so irrelevant code is never even built.</p>"},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/#usage-forms","title":"Usage Forms","text":""},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/#attributes","title":"Attributes","text":"<pre><code>#[cfg(target_os = \"linux\")]\nfn special_linux_function() { /* ... */ }\n\n#[cfg(feature = \"serde\")]\nmod with_serde;\n</code></pre>"},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/#inline-expressions-cfg-macro","title":"Inline Expressions (<code>cfg! macro</code>)","text":"<ul> <li><code>cfg!</code> expands to a <code>bool</code> at runtime (evaluated at compile-time, but value is inlined).</li> </ul> <pre><code>if cfg!(target_os = \"windows\") {\n    println!(\"Running on Windows!\");\n}\n</code></pre>"},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/#conditional-attributes-cfg_attr","title":"Conditional Attributes (<code>cfg_attr</code>)","text":"<ul> <li>If this <code>cfg condition is true</code>, <code>apply this other attribute</code>. If not, ignore it.</li> </ul> <pre><code>#[cfg_attr(feature = \"serde\", derive(serde::Serialize, serde::Deserialize))]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n</code></pre>"},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/#common-predicates","title":"Common Predicates","text":"<ul> <li><code>target_os = \"linux\" | \"windows\" | \"macos\" | ...</code></li> <li><code>target_arch = \"x86\" | \"x86_64\" | \"arm\" | ...</code></li> <li><code>target_pointer_width = \"32\" | \"64\"</code></li> <li><code>debug_assertions</code> \u2192 <code>true</code> in debug builds</li> <li><code>feature = \"name\"</code> \u2192 enabled Cargo feature (specify in <code>Cargo.toml</code>)</li> </ul> <p>What is <code>debug_assertions</code>?</p> <p>This is enabled by default in debug builds and disabled in release builds. It allows you to include code that should only run in debug mode, such as additional checks or logging.</p> <pre><code>fn main(){\n    if cfg!(debug_assertions){\n        println!(\"debug mode\");\n    } else {\n        println!(\"release mode\");\n    }\n}\n</code></pre> <ul> <li>run in debug &amp; release mode:</li> </ul> <pre><code>cargo run # default is debug\ncargo run --release # release mode\n</code></pre>"},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/#compound-conditions","title":"Compound Conditions","text":"<pre><code>#[cfg(all(unix, feature = \"logging\"))]\nfn log_unix() {}\n\n#[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\nfn posix_only() {}\n\n#[cfg(not(feature = \"gui\"))]\nfn headless() {}\n</code></pre>"},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/#cargo-integration","title":"Cargo Integration","text":""},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/#features-are-defined-in-cargotoml","title":"Features are defined in <code>Cargo.toml</code>:","text":"<pre><code>[features]\ndefault = []\nserde = [\"serde_crate\"]\nextra = []\n</code></pre> <ul> <li>A feature is a mapping: <code>name = [ list of other features or optional deps ]</code>.</li> <li><code>default</code> (special) \u2192 automatically enabled unless <code>--no-default-features</code>.</li> <li>Entries in the list can be:<ul> <li>another feature name (enables that feature),</li> <li><code>dep:NAME</code> to pull in an optional dependency.</li> </ul> </li> </ul>"},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/#example","title":"Example","text":"<pre><code>[dependencies]\ndep1 = { version = \"1\", optional = true }\ndep2 = { version = \"1\", optional = true }\ndep3 = { version = \"1\", optional = true }\n\n[features]\ndefault = []\nfeat1 = [\"dep:dep1\", \"dep:dep2/featureA\"]\nfeat2 = [\"feat1\", \"dep:dep3\"]\n</code></pre> <ul> <li>All features are disabled by default. To make them enabled by default, add them to <code>default</code>:</li> </ul> <pre><code>[features]\ndefault = [\"feat1\"]\nfeat1 = [\"dep:dep1\", \"dep:dep2/featureA\"]\n</code></pre> <ul> <li><code>cargo run --features feat2</code> \u2192 enables <code>feat2</code>, which pulls in <code>feat1</code>, <code>dep1</code>, <code>dep2</code>, and <code>dep3</code>.</li> <li>Optional deps (<code>optional = true</code>) are not included unless gated behind a feature that enables them.</li> <li>To enable specific feature of dependency: <code>dep_name/feature_name</code>.</li> <li>Use <code>?/</code> to make a feature optional: <code>dep_name?/feature_name</code>. It means, \"if <code>dep_name</code> is already included (by default or some other feature), then only enable <code>feature_name</code>\".</li> </ul> see example from tokio project <pre><code>[package]\nname = \"tokio-stream\"\n# When releasing to crates.io:\n# - Remove path dependencies\n# - Update CHANGELOG.md.\n# - Create \"tokio-stream-0.1.x\" git tag.\nversion = \"0.1.17\"\nedition = \"2021\"\nrust-version = \"1.70\"\nauthors = [\"Tokio Contributors &lt;team@tokio.rs&gt;\"]\nlicense = \"MIT\"\nrepository = \"https://github.com/tokio-rs/tokio\"\nhomepage = \"https://tokio.rs\"\ndescription = \"\"\"\nUtilities to work with `Stream` and `tokio`.\n\"\"\"\ncategories = [\"asynchronous\"]\n\n[features]\ndefault = [\"time\"]\n\nfull = [\n    \"time\",\n    \"net\",\n    \"io-util\",\n    \"fs\",\n    \"sync\",\n    \"signal\"\n]\n\ntime = [\"tokio/time\"]\nnet = [\"tokio/net\"]\nio-util = [\"tokio/io-util\"]\nfs = [\"tokio/fs\"]\nsync = [\"tokio/sync\", \"tokio-util\"]\nsignal = [\"tokio/signal\"]\n\n[dependencies]\nfutures-core = { version = \"0.3.0\" }\npin-project-lite = \"0.2.11\"\ntokio = { version = \"1.15.0\", path = \"../tokio\", features = [\"sync\"] }\ntokio-util = { version = \"0.7.0\", path = \"../tokio-util\", optional = true }\n\n[dev-dependencies]\ntokio = { version = \"1.2.0\", path = \"../tokio\", features = [\"full\", \"test-util\"] }\nasync-stream = \"0.3\"\nparking_lot = \"0.12.0\"\ntokio-test = { version = \"0.4\", path = \"../tokio-test\" }\nfutures = { version = \"0.3\", default-features = false }\n\n[package.metadata.docs.rs]\nall-features = true\nrustdoc-args = [\"--cfg\", \"docsrs\"]\n# Issue #3770\n#\n# This should allow `docsrs` to be read across projects, so that `tokio-stream`\n# can pick up stubbed types exported by `tokio`.\nrustc-args = [\"--cfg\", \"docsrs\"]\n\n[lints]\nworkspace = true\n</code></pre> <ul> <li><code>tokio/sync</code> feature is included by default, bcoz no <code>optional = true</code>. But, other features like <code>tokio/fs</code> is enabled only when using <code>--features fs</code>.</li> </ul>"},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/#using","title":"Using:","text":"<pre><code>#[cfg(feature = \"extra\")]\nfn fancy() {}\n</code></pre> <ul> <li>Enable with:</li> </ul> <pre><code>cargo build --features serde\ncargo build --features \"serde extra\"\ncargo test --no-default-features --features serde\n</code></pre>"},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/#dependencies-per-feature","title":"Dependencies per feature","text":"<pre><code>[dependencies]\nserde = { version = \"1\", optional = true }\nregex = { version = \"1\" }\n\n[features]\ndefault = [\"regex\"]\nserde_support = [\"serde\"]\n</code></pre> <ul> <li><code>optional = true</code> \u2192 only included if its feature is enabled.</li> </ul>"},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/#tests-with-cfg","title":"Tests with <code>cfg</code>","text":"<pre><code>#[cfg(test)]\nmod tests {\n    #[test]\n    fn basic() {}\n}\n\n#[cfg(all(test, feature = \"serde\"))]\nmod serde_tests {\n    #[test]\n    fn test_with_serde() {}\n}\n</code></pre>"},{"location":"04-advanced/01-build-and-ffi/01-conditional-compilation/#notes","title":"Notes","text":"<ul> <li><code>#[cfg]</code> removes code entirely at compile-time.</li> <li><code>cfg!</code> only provides a <code>bool</code>; it does not remove code.</li> <li><code>cfg_attr</code> allows for conditional attributes.</li> <li>Use attributes for conditional modules, imports, or functions.</li> <li>Use <code>cfg!</code> for branching in code paths.</li> </ul>"},{"location":"04-advanced/01-build-and-ffi/02-build-rs/","title":"<code>build.rs</code> in Rust Projects","text":"<ul> <li>The <code>build.rs</code> file is a special build script in Rust projects that allows you to customize the build process.</li> <li>It is executed before the main compilation of your crate and can be used for various tasks such as:<ul> <li>generating code</li> <li>compiling C/C++ code</li> <li>or setting up environment variables.</li> </ul> </li> </ul>"},{"location":"04-advanced/01-build-and-ffi/03-rust-calling-c-code/","title":"Calling <code>C</code> code from <code>rust</code>","text":"<ul> <li>File structure:</li> </ul> <pre><code>\u251c\u2500\u2500 build.rs\n\u251c\u2500\u2500 Cargo.lock\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 hello.c\n    \u2514\u2500\u2500 main.rs\n</code></pre>"},{"location":"04-advanced/01-build-and-ffi/03-rust-calling-c-code/#install-cc-as-build-dependency","title":"Install <code>cc</code> as build-dependency","text":"<pre><code># Cargo.toml file\n\n[build-dependencies]\ncc = \"1.2.38\"\n</code></pre>"},{"location":"04-advanced/01-build-and-ffi/03-rust-calling-c-code/#create-buildrs-file","title":"Create <code>build.rs</code> file","text":"<pre><code>// build.rs file\nfn main() {\n    // Tell Cargo that if the given file changes, to rerun this build script.\n    println!(\"cargo::rerun-if-changed=src/hello.c\");\n    // Use the `cc` crate to build a C file and statically link it.\n    cc::Build::new().file(\"src/hello.c\").compile(\"hello\");\n}\n</code></pre>"},{"location":"04-advanced/01-build-and-ffi/03-rust-calling-c-code/#create-c-file","title":"Create <code>C</code> file","text":"<pre><code>// src/hello.c file\nint add(int a, int b) {\n    return a + b;\n}\n</code></pre>"},{"location":"04-advanced/01-build-and-ffi/03-rust-calling-c-code/#srcmainrs-file","title":"<code>src/main.rs</code> file","text":"<pre><code>// Tell Rust there\u2019s an external C function called `add`.\n// Signature must match the C function exactly.\nunsafe extern \"C\" {\n    unsafe fn add(a: i32, b: i32) -&gt; i32;\n}\n\nfn main() {\n    let result = unsafe { add(2, 3) };\n    println!(\"2 + 3 = {}\", result);\n}\n</code></pre>"}]}